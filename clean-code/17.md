# 17장 냄새와 휴리스틱



### 주석

#### 부적절한 정보

주석은 코드와 설계에 기술적인 설명을 부연하는 수단이므로, 다른 시스템에 저장해도 되는 정보는 주석으로 달지 말자



#### 쓸모 없는 정보

오래된 주석, 엉뚱한 주석, 잘못된 주석 등 쓸모 없거나/쓸모 없어질 주석은 아예 달지 말자

주석은 빨리 낡고, 코드와 따로놀게 되며 코드를 오히려 잘못된 방향으로 이끌기도 한다



#### 중복된 주석

주석은 코드로만 다 하지 못하는 설명을 부연해야 하고, 단순 코드 내용을 설명하는 주석은 불필요하다



#### 성의없는 주석

주석을 달아야 한다면, 단어, 문법, 구두점을 올바로 사용하고 주절대지않고, 당연한 소리를 반복하지 않고 간결하고 명료하게 작성하자



#### 주석 처리된 코드

어떤 코드인지 파악이 어려워지므로 삭제하자 (진짜 필요한 거였다면 소스 코드 관리 시스템에서 확인 하면 됨)



### 환경

#### 여러 단계로 빌드해야 한다 (X)

한 단계로 한 번에 빌드할 수 있어야 한다

#### 여러 단계로 테스트 해야 한다 (X)

명령 하나로 모든 테스트를 한 번에 할 수 있어야 한다



### 함수

#### 너무 많은 인수

함수에서 인수 개수는 작을 수록 좋다 (0\~3개)



#### 출력 인수

보통 인수는 입력으로 간주하기 때문에, 함수 내에서 값을 변경하는 등 출력 인수를 사용하지 말자

꼭 내부에서 상태를 변경해야 한다면 함수가 속한 객체의 상태를 변경하자



#### 플래그 인수

함수가 여러 동작을 한다는 의미이므로 사용을 피하자



#### 죽은 함수

아무도 호출하지 않는 함수는 삭제하자



### 일반

#### 한 소스 파일에 여러 언어를 사용한다 (X)

소스 파일 하나에 언어 하나만 사용하고, 최대한 소스파일에서 언어 수와 범위를 줄이자



#### 당연한 동작을 구현하지 않는다 (X)

최소 놀람의 원칙The Principle of Least Surprise에 의거해 함수나 클래스는 다른 프로그래머 당연하게 여길 만한 동작과 기능을 제공해야 한

당연한 동작을 구현해야 함수 이름만으로도 기능을 직관적으로 예상할 수 있다



#### 경계를 올바로 처리하지 않는다 (X)

모든 경계 조건, 모든 구석진 곳, 모든 기벽, 모든 예외를 다 살펴보고 테스트하자



#### 안전 절차 무시 (X)

컴파일러의 경고를 무시하지 말고, 실패하는 테스트 케이스를 제끼고 나중으로 미루지 말자



#### 중복

DRY - Don't Repeat Yourself / 한 번, 단 한 번만 Once and only once

* 중복된 코드를 발견한다면 추상화로 정리할 기회로 삼자
* 똑같은 코드가 여러 차례 나오는 경우 간단한 함수로 교체하자
* 여러 모듈에서 switch/case, if/else 문으로 똑같은 조건을 거듭 확인하는 경우 다형성으로 처리하자
* 알고리즘이 유사하지만 코드가 다른 중복인 경우 TEMPLATE METHOD 패턴이나 STRATEGY 패턴으로 중복을 제거하자



#### 추상화 수준이 올바르지 못하다

모든 저차원 개념은 파생 클래스에, 모든 고차원 개념은 기초 클래스에 넣고 이 두 개념을 섞어서는 안된다

* 기초 클래스는 구현 정보에 무지해야 한다

```java
public interface Stack {
    Object pop() throws EmptyException;
    void push(Object o) throws FullException;
    double percentFull(); // 올바르지 않은 추상화 수준
    class EmptyException extends Exception {}
    class FullExceptoin extends Exception {}
}
```



#### 기초 클래스가 파생 클래스에 의존한다 (X)

기초 클래스와 파생 클래스로 나누는 가장 흔한 이유는&#x20;

* 고차원 기초 클래스 개념을 저차원 파생 클래스 개념으로터 분리해 독집성을 보장하기 위해서다
* 일반적으로 기초 클래스는 파생 클래스를 몰라야한다

기초 클래스가 파생 클래스를 몰라야 변경이 시스템에 미치는 영향도 작아져서 유지보수가 더 쉬워진다



#### 과도한 정보

잘 정의된 모듈은 인터페이스가 아주 작고, 많은 함수를 제공하지 않는다(정보를 제한하면 결합도가 낮아진다)

* 자료, 유틸리티 함수, 상수와 임시 변수를 숨기고,&#x20;
* 하위 클래스에서 필요하다는 이유로 protected를 남발하지 말고,&#x20;
* 노출할 함수를 제한해서 꼭 필요한 정보만 노출하자



#### 죽은 코드

실행되지 않는 코드는 제거하자

* 불가능한 조건을 확인하는 if문
* throw 문이 없는 try 문에서 catch 블록
* 아무도 호출하지 않는 유틸리티 함수
* switch/case 문에서 불가능한 case 조건



#### 수직 분리

변수와 함수는 사용하는 위치에 가깝게 정의하자



#### 일관성 부족

표기법은 신중하게 선택하고, 일단 선택했다면 신중하게 따르자

일관성이 있는 코드는 코드를 읽고 수정하기 쉽게 만들어준다



#### 잡동사니

코드를 복잡하게만 만드는 잡동사니는 다 제거하자!

* 비어있는 기본 생성자
* 사용하지 않는 변수, 아무도 호출하지 않는 함수
* 정보를 제공하지 못하는 주석



#### 인위적인 결합

서로 무관한 개념을 인위적으로 결합하지 말자

뚜렷한 목적없이 변수, 상수, 함수를 당장 편한 위치에 넣어버리지 말자

* enum 클래스나 static 함수가 특정 클래스에 속해야 할 이유가 있을까?



#### 기능 욕심

클래스 메서드는 자기 클래스의 변수와 함수에만 관심을 가져야 한다!

* 다른 객체의 참조자와 변경자를 사용해서 그 객체 내용을 변경 하는 등, 객체 클래스의 범위를 욕심내지 말자

기능 욕심은 한 클래스의 속사정을 다른 클래스에 노출하게 되므로 주의



#### 선택자 인수

인수를 넘겨서 선택하게 만들지 말고 새로운 함수로 쪼개는 게 더 좋은 선택일 수도 있다

* `WeeklyPay(false)` 같은 코드를 봤을 때 이 false 가 정확히 무얼 의미하는 지 분명하지 않음



#### 모호한 의도

의도를 최대한 분명히 밝히자

* 의도를 흐리는&#x20;
  * 행을 바꾸지 않고 표현한 수식
  * 헝가리식 표기법
  * 매직 번호



#### 잘못 지운 책임

코드를 적절한 위치에 잘 배치해야 한다



#### 부적절한 static 함수

어떤 메서드를 재정의 할 가능성이 전혀 없고, 특정 인스턴스와 관련이 없는 기능들이라면 static 메서드로 정의하지만(ex. Math.max()), 재정의할 가능성이 조금이라도 의심된다면 인스턴스 함수로 작성하자



#### 서술적 변수

계산을 여러 단계로 나누고 중간 값으로 서술적인 변수 이름을 사용해서 가독성을 높이자 (많이 써도 괜찮음\~!)

```java
Matcher match = headerPattern.matcher(line);
if (match.find()) {
    String key = match.group(1); // 서술적인 변수
    String value = match.group(2); // 서술적인 변수
    headers.put(key.toLowerCase(), value);
}
```



#### 이름과 기능이 일치하는 함수

이름만으로 분명하지 않다면, 더 좋은 이름을 붙이거나 좋은 이름을 붙일 수 있도록 기능을 정리하자



#### 알고리즘을 이해하라

이리저리 덕지덕지 코드를 붙여가면서 돌려보고 '돌아 갈'때까지 찔러 보면서 코드를 작성하다가도, 함수가 돌아가는 방식을 확실히 이해했는지 확인하자

* 코드가 돌아가는 것을 아는 것과, 돌아가기 위한 알고리즘이 올바르다는 사실은 다른 것!!

알고리즘이 올바르다는 사실을 확인하고 이해하려면, 기능이 뻔히 보일 정도로 함수를 깔끔하고 명확하게 재구성하는 방법이 최고다



#### 논리적 의존성은 물리적으로 드러내라

의존하는 모듈이 상대 모듈에 대해 뭔가를 가정하면 안된다 (논리적으로 의존하면 안된다)

의존하는 모든 정보를 명시적으로 요청하는 편이 좋다



#### if/else, switch/case 문보다 다형성을 사용하자

손쉬운 선택인 switch/case 를 사용하지말고 다형성을 먼저 고려해보자

####

#### 표준 표기법을 따르라

팀은 업계 표준에 기반한 구현 표준을 따라야 하고, 팀이 정한 표준은 팀원 모두가 따라야 한다



#### 매직 숫자는 명명된 상수로 교체하라

코드에서 매직 숫자를 사용하지 말고, 상수를 사용하자

* 이때 매직 숫자는 단순한 숫자만 의미하는 것이 아니라 의미가 분명하지 않은 토큰 모두를 가리킨다

그냥 숫자를 남겨두는 편이 더 좋을 때도 있지만, 오류가 발생할 가능성이 높은 매직 숫자는 상수로 관리하자



#### 정확하라

코드 내에서 뭔가를 결정할 때는 정확히 결정하자 (모호성과 부정확은 게으름의 결과일 뿐!!!)

결정을 내리는 이유와 예외를 처리할 방법을 분명히 알아야 한



#### 관례보다 구조를 사용하라

설계 결정을 강제할 때는 규칙보다 관례를 사용한다 (구조 자체로 강제하면 더 좋다)

* ex) switch/case 문을 매번 똑같이 구현하라고 강제하기는 어렵지만, 파생 클래스를 사용한다면 추상 메서드를 모두 구해야 하므로 강제할 수 있다



#### 조건을 캡슐화 하라

조건문 내의 조건은 이해하기 어려울 수 있으므로 조건의 의도를 분명히 밝히는 함수로 표현하자

* ex) `if (timer.hasExpired() && !timer.isRecurrent())` -> `if` `(shouldBeDeleted(timer))`

#### 부정 조건은 피하라

부정 조건은 이해하기 어렵다. 가능한 긍정 조건으로 표현하자

* ex) `if (!buffer.shouldNotCompact())` -> `if (buffer.shouldCompact())`&#x20;

#### 함수는 한 가지만 해야 한다

한 함수가 한가지 일만 수행할 수 있도록, 많은 동작을 수행하는 함수는 적절하게 작은 함수들로 쪼개자

#### 숨겨진 시간적인 결합

때로는 시간적인 결합이 필요한데, 이 시간적인 결합을 숨겨서는 안된다

호출되는 순서를 명백히 드러내야 한

* ex) 연결 소자를 생성해서 시간적인 결합을 노출시키기



#### 일관성을 유지하라

구조가 일관성있어야 남들도 일관성을 따르고 보존할 수 있게 된다



#### 경계 조건을 캡슐화하라

경계 조건은 한 곳에 모아 별도로 처리하자

```java
parts = new Parse(body, tags, level + 1, offset + endTag);

// 개선
int nextLevel = level + 1;
parts = new Parse(body, tags, nextLevel, offset + endTag);
```



#### 함수는 추상화 수준을 한 단계만 내려가야 한다

함수 내 모든 문장은 추상화 수준이 동일해야 하고, 그 추상화 수준은 이름이 의미하는 작업보다 한 단계만 낮아야 한다

추상화 수준이 섞이지 않도록 잘 분하자 (리팩토링 작업 중 가장 어려운 작업 중 하나ㅠ)



#### 설정 정보는 최상위 단계에 둬라

추상화 최상위 단계에 둬야할 기본값 상수나 설정 관련 상수를 저차원 함수에 숨기지 말

#### 추이적 탐색을 피하라

자신이 직접 사용하는 모듈만 알아야 한다 (체인처럼 연결돼서 다른 모듈들을 휘젓고 다니면 안된다!)

* A가 B를 사용하고, B가 C사용한다고 해도 A 가 C를 알 필요는 없다
* `a.getB().getC().doSomething();` 이런식으로 사용하지 말 것!!

디미터의 법칙Law of Demeter / 부끄럼 타는 코드 작성Writing Shy Code

너무 많은 모듈이 아키텍쳐를 너무 많이 알게 되면 변경하기 어렵고, 이해하기 위해 이리저리 탐색하고 다녀야 한



### 자바

#### 긴 Import 목록을 피하고 와일드카드를 사용하라

패키지에서 클래스를 둘 이상 사용한다면 와일드카드를 사용해 패키지 전체를 가져오자

`import package.*'`

와일드카드는 특정 클래스가 반드시 존재할 필요는 없기때문에 진정한 의존성이 생기지 않아서 모듈간 결합도를 낮출 수 있다

가끔 이름 충돌이나 모호성을 초래할 수도 있으므로, 그때는 명시적인 import 문을 사용하자

#### 상수는 상속하지 않는다

상수를 상속 계층 맨 위에 숨겨놓고 사용하지 말자 (대신 static import 를 사용하자)

#### 상수 vs Enum

public static final int 라는 옛날 기교를 사용하지 않아도 되고, enum은 훨씬 유연하고 서술적인 강력한 도구다!

###

### 이름

#### 서술적인 이름을 사용하라

신중하게 서술적인 이름을 작성한다면 가독성을 크게 높일 수 있다

#### 적절한 추상화 수준에서 이름을 선택하라

구현을 드러내는 이름을 피하고, 작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택하자

#### 가능하다면 표준 명명법을 사용하라

기존 명명법이 있다면 이를 활용해서 이름을 짓자

* DECORATOR 패턴을 활용한 클래스에 decorator 단어 쓰기
* 자바에서 객체를 문자열로 변환할 때 toString이름을 쓰는데, 이런 관례를 따르기
* 팀 내 표준 따르기



#### 명확한 이름

엄청나게 긴 이름이더라도 더 서술적이고 함수를 잘 표현한다면 그 이름을 사용하자

* doRename -> renamePageAndOptionallyAllReferences

#### 긴 범위는 긴 이름을 사용하라

범위가 길어지면 긴 이름을 사용하자

* 범위가 5줄 안팍이라면 i나 j 같은 변수 이름도 괜찮다 (ex. 짧은 for문)

#### 인코딩을 피하라

이름에 유형 정보나 범위 정보를 넣어서 독자가 한 번 더 해석하게 하지 말

#### 이름으로 부수 효과를 설명하라

함수, 변수, 클래스가 하는 일을 모두 기술하는 이름을 사용하고, 부수효과를 숨기지 말자



### 테스트

#### 불충분한 테스트

테스트 케이스가 확인하지 않는 조건이나 검증하지 않는 계산이 있다면 그 테스트는 불완전하

#### 커버리지 도구를 사용하라

테스트가 빠뜨리는 공백을 찾기 위해 커버리지 도구를 사용하자

#### 사소한 테스트를 건너뛰지 마라

사소한 테스트는 짜기 쉽지만, 제공하는 가치는 구현에 드는 비용을 넘어선다

#### 무시한 테스트는 모호함을 뜻한다

불분명한 요구사항은 테스트 케잇를 주석으로 처리하거나, 테스트케이스에 @Ignore를 붙여서 표현한다

#### 경계 조건을 테스트하라

각별히 신경써서 테스트하자

#### 버그 주변은 철저히 테스트하라

버그는 서로 모이는 경향이 있으므로, 버그 주변을 꼼꼼히 테스트하자 (새로운 버그를 발견하게 될 수도!)

#### 실패 패턴을 살펴라

매번 실패하는 패턴을 발견한다면, 패턴만 보고도 쉽게 버그를 찾을 수 있을 것이다

#### 테스트 커버리지 패턴을 살펴라

통과하는 테스트가 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 테스트 케이스의 실패 원인이 드러난다

#### 테스트는 빨라야 한다

테스트 케이스가 빨리 돌아가야 많이 테스트를 해볼 수 있다

###

### 결론

전문가 정신과 장인 정신은 가치에서 나오고, 그 가ㅔ 기반한 규율과 절제가 필요하다





