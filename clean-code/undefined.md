# 부록 - 동시성



### 단일 스레드 -> 다중 스레드로 변경

애플리케이션이 시간을 오래 보내는 데 두가지 이유가 있을 수 있음

* I/O - 소켓 사용, 데이터베이스 연결, 가상 메모리 스와핑 기다리기
* 프로세서 - 수치 계산, 정규 표현식 처리, 가비지 컬렉션

성능 개선을 위해서 다른 해결방법으로 접근해야 함

* I/O -> 동시성(다중 스레드)
* 프로세서 -> 새로운 하드웨어 추가

다중 스레드로 변경할 경우, 스레드 관리 책임을 클래스로 **분리**하는 것이 좋다 (단일 책임 원칙 중요!!)

* 스레드 관리 전략이 변할 때, 전체 코드에 미치는 영향이 적어지고, 다른 책임을 간섭하지 않아도 됨
* 동시성 문제가 생긴 경우 해당 클래스만 살펴보면 됨
* 스레드를 걱정하지 않고 다른 책임을 테스트하기 쉬워짐



### 가능한 실행 경로

```java
public class IdGenerator {
    int lastIdUsed;
    
    public int incrementValue() {
        return ++lastIdUsed;
    }
}
```

#### 경로 수

`return ++lastIdUsed;` 자바코드 한 줄은 바이트 코드 명령 8개에 해당한다

* 이때 두 스레드가 명령 8개를 섞어서 실행할 가능성이 있음
* 루프나 분기가 없는 명령 N개를 스레드 T개가 차례로 실행한다면 가능한 경로 수는 $$(NT)! / N!^t$$​

ex) 자바 코드 한 줄이 N=8 스레드 개수 T=2 인 경우

* 가능한 경로 수는 12,870개
* long 정수라면 읽기/쓰기 명령이 두 단계로 실행되므로 가능한 경로 수는 2,704,156 개

만약 synchronized 키워드를 붙이게 된면 가능한 경로 수는 -> (스레드 개수 N개인 경우) $$N!$$ 개다



#### 어떻게 두 스레드가 같은 메서드를 한 번씩 호출해서 같은 값을 얻는 경우가 생길까?

`++` 이 전처리 연산이 **중단 가능한 연산**이기 때문!

* 중단이 불가한 연산인 원자적 연산atomic operation이 아니라면, 연산 중간에 다른 스레드가 끼어들어서 값이 변경될 수 있음
* 원자적 연산이라면 다른 스레드로 간섭을 받더라도, 경로가 엄청 많더라도 최종 결과가 변하지 않음

#### **바이트 코드를 상세히 살펴보자**👀

* 기본 개념
  * 프레임frame : 반환 주소, 메서드로 넘어온 매개변수, 메서드가 정의하는 지역 변수로, 호출 스택call stack을 정의할 때 사용하는 표준 기법
  * 지역 변수local variables : 메서드 범위 내 정의되는 모든 변수로, 정적 메서드를 제외하고 모든 메소드는 기본적으로 this라는 지역변수를 가진다 (this - 현재 객체, 즉 현재 스레드에서 가장 최근에 메세지를 받아 메서드를 호출한 객체)
  * 피연산자 스택operand stack : 매개변수를 저장하는 장소로, 표준 LIFO last in, first out 구조



```java
public class Example {
    int lastId;
    
    public void resetId() {
        lastId = 0;
    }
    
    public int getNextId() {
        ++lastId;    
    }
}
```

p418 참고

중간에 다른 스레드가 끼어들어서 모든 명령을 수행하고, 그 뒤에 원래 진행하던 스레드가 다시 명령을 수행하게 되면 값이 덮어씌워지면서 원치않은 결과가 발생하게 될 수 있다

#### 어떤 연산이 안전하고, 안전 하지 못한지 메모리 모델을 이해할 필요가 있음

* 원자적 연산이 아닌 경우, 다음을 알고 있어야 함
  * 공유 객체/값이 있는 곳
  * 동시 읽기/수정 문제를 일으킬 소지가 있는 코드
  * 동시성 문제를 방지하는 법



### 라이브러리를 이해하자

#### Executor 프레임워크

* java.util.concurrent 패키지에 속하는 클래스
* 스레드 풀을 관리하고, 풀 크기를 자동으로 조정하며, 필요하다면 스레드를 재사용
* 다중 스레드 프로그래밍에서 많이 사용하는 Future도 지원&#x20;
  * Future - 독립적인 연산 여럿을 실행한 후 모두가 끝나기를 기다릴 때 유용
* Runnable 인터페이스를 구현한 클래스 / Callable 인터페이스를 구현한 클래스 지원

아래와 같은 상황일 때 사용을 고려해볼 것!

* 애플리케이션에서 스레드는 생성하지만 스레드 풀을 사용하지 않는 경우
* 직접 생성한 스레드 풀을 사용하는 경우



#### 스레드를 차단하지 않는non-blocking 방법

synchronized 키워드는 언제나 락lock을 걸어서 스레드를 차단하는데, 락을 거는 비용은 비싸다

차단하지 않도록 프로그램을 작성하려면

* 기본 유형 대신 객체를 사용하기 (int -> AtomicInteger())
* 중단되지 않는 연산자 사용하기 (++ -> incrementAndGet())

현대 프로세서는 중단하기 않게 하기 위해서 CAS compare and swap 이라는 연산을 지원한다

* 여러 스레드가 같은 값을 수정해 문제가 생기는 상황이 그리 잦지는 않다는 가정에서 출발
* 그래서 그런 상황이 생겼을 때 효율적으로 감지해서 갱신이 성공할 때 까지 시도
  * ex) 메서드가 공유 변수를 갱신하려고 할 때, CAS 연산은,,
    * 현재 변수 값이 최종으로 알려진 값인지 확인 후 갱신
    * 아니라면 중간에 다른 스레드가 끼어들었다는 의미이므로 값 갱신하지 않음
* 문제를 감지하는 방식이 매번 락을 거는 것보다 효율적이다!



#### 다중 스레드 환경에서 안전하지 않는 클래스

안전하지 않은 클래스

* SimpleDateFormat
* 데이터베이스 연결
* java.util 컨테이너 클래스
* 서블릿

스레드에 안전한 메서드를 사용하더라도, 여러개를 호출하는 상황이라면 스레드에 안전하지 않음

* 각 메서드는 안전하지만, containsKey와 put 사이에 다른 스레드가 끼어들어 값을 추가할지도 모른다,,

```java
if (!hashTable.containsKey(someKey)) {
    hashTable.put(someKey, new SomeValue());
}
```

해결방안 세 가지

1. HashTable을 잠근다
2. HashTable을 객체로 감싼후 다른 API를 사용한다 (ADAPTER 패턴 사용)
3. 스레드에 안전한 집합 클래스를 사용한

```java
// 방법 1
synchronized(map) {
    if (!map.containsKey(key)) {
        map.put(key, value);
    }
}

// 방법 2
public class WrappedHashTable<K, V> {
    private Map<K, V> map = . ew Hashtable<K, V>();
    
    public synchronized void putIfAbsent(K key, V value) {
        if (map.containsKey(key)) {
            map.put(key, value)
        }
    }
}

// 방법 3
ConcurrentHashMap<Integer, String> map = new ConcurerntHashMap<Integer, String>();
map.putIfAbsent(key, value); // putIfAbsent - 스레드에 안전한 메서드
```



### 메서드 사이에 존재하는 의존성을 조심하라

#### 의존성 문제 해결방법 세가지

* 실패를 용인한다
* 클라이언트-기반 잠금
* 서버-기반 잠금

#### 방법 1) 실패를 용인한다

때로는 실패해도 괜찮도록 프로그램을 조정 ex) 클라이언트가 예외를 받아서 처리하도록

조잡한,, 방법

#### 방법 2) 클라이언트-기반 잠금

(모든) 클라이언트를 수정

단,, 만약 실수를 해서 하나라도 처리를 빼먹는다면 문제를 발견&해결하기 어려워질 수 있다

#### 방법 3) 서버-기반 잠금

일반적으로 바람직한 방법

* 코드 중복이 줄어든다 (각 클라이언트가 알아서 서버를 잠그는 코드는 중복을 야기)
* 성능이 좋아진다 (서버만 교체하면 오버헤드가 줄어듬)
* 오류가 발생할 가능성이 줄어든다 (잠금을 하지 않아서 발생하는 위험은 서버 개발자 한 명(?)에게 국한됨)
* 스레드 정책이 하나
* 공유 변수 범위가 줄어듬 (서버에서 처리하므로 클라이언트는 관련 사항을 몰라도 됨, 문제가 발생했을 때 서버 한 곳만 확인해보면 됨)

서버 코드에 손을 대지 못하는 상황이라면,,

* ADAPTER 패턴을 사용해 API를 변경한 후 잠금 추가
* 스레드에 안전하며 인터페이스가 확장된 집합 클래스를 사용하기

### 작업 처리량 높이기

#### 작업 처리량 계산 - 단일 스레드 환경 p430

#### 작업 처리량 계산 - 다중 스레드 환경 p431



다중 스레드를 사용한다면 (이상적으로는) 프로세서를 100% 활용할 수 있어서, 단일 스레드에 비해 처리율이 높아진다!



### 데드락

아래 네가지 조건을 모두 만족하면(ㅋㅋ;;) 데드락이 발생한다

* 상호 배제 Mutual exclusion
* 잠금&대기 Lock\&Wait
* 선점 불가 No Preemption
* 순환 대기 Circular Wait

#### 상호 배제 Mutual Exclusion

여러 스레드가 한 자원을 공유하지만

* 그 자원이 여러 스레드가 동시에 사용하지 못하고
* 개수가 제한적이라면 발생

ex) 데이터베이스 연결, 쓰기용 파일 열기, 레코드 락, 세마포어

#### 잠금 & 대기 Lock & Wait

스레드가 자원을 점유하면 필요한 나머지 자원까지 모두 점유해서 작업을 마칠 때 까지 점유하고 있는 자원을 내놓지 않음

#### 선점 불가 No Preemption

한 스레드가 다른 스레드로부터 자원을 빼앗지 못해서, 자원을 점유한 스레드가 스스로 내놓지 않는 이상 다른 스레드가 그 자원을 점유하지 못한다

#### 순환 대기 Circular Wait (죽음의 포옹 deadly embrace)

스레드 T1, T2 자원 R1, R2 가 있다고 할 때

* T1 이 R1 점유, T2 이 R2 를 점유한 상황인데,
* T1은 R2 가 필요하고, T2 도 R1 이 필요한 상황

? 그림이랑 말이랑 안맞는데 (p434)



데드락은 위 네 조건 중 하나만 깨져도 발생하지 않는다!

#### 상호 배제 조건 깨기

* 동시에 사용해도 괜찮은 자원 사용하기 (ex. AtomicInteger)
* 스레드 수 이상으로 자원 수 늘리기
* 자원을 유하기 전에 필요한 자원이 모두 있는지 확인하기

단,, 대다수의 자원들은 수가 제한적이고 동시에 사용하기 어렵고, 필요한 자원이 첫번째 자원을 사용하고 난 뒤에 밝혀지는 경우도 있다

#### 잠금&대기 조건 깨기

* 각 자원을 점유하기 전에 확인 -> 어느 하나라도 점유하지 못한다면 지금까지 점유한 자원을 몽땅 내놓고 처음부터 다시 시작

단, 위 방법은 아래와 같은 문제가 발생해서 작업 처리량을 크게 떨어뜨릴 가능성이 있다.&#x20;

* 기아 Starvation&#x20;
  * 한 스레드가 필요한 자원을 계속 점유하지 못함&#x20;
  * 점유하려는 자원이 한꺼번에 확보하기 어려운 상황일때 발생
  * CPU 효율 저하
* 라이브락 Livelock
  * 여러 스레드가 한꺼번에 잠금 단계에 진입해서 점유한 자원을 점유했다 내놨다를 반복&#x20;
  * 단순한 CPU 스케쥴링 알고리즘에서 특히 쉽게 발생
  * CPU만 쓸데없이 많이 사용

#### 선점 불가 조건 깨기

* 필요한 자원이 잠겼다면 자원을 소유한 스레드에게 풀어달라고 요청 -> 요청을 받은 스레드가 다른 자원을 기다리던 중이었다면 자신이 소유한 자원을 모두 풀어주고 처음부터 다시 시작

잠금&대기와 비슷하지만 스레드가 자원을 기다려도 괜찮다는 이점이 있고, 처음부터 다시 시작하는 횟수가 줄어든다

단,, 이 모든 요청을 관리하기가 어렵다ㅠ

#### 순환 대기 조건 깨기

* 모든 스레드가 일정 순서에 동의하고 그 순서로만 자원을 할당하게 하기

단, 아래와 같은 문제가 발생할 수 있다

* 자원을 할당하는 순서와 사용하는 순서가 다를 수 있음, 이 경우 너무 오랫동 자원을 점유하게 될 수도
* 때로는 순서에 따라 자원을 할당하기 어려울 수 있음, 첫 자원을 사용하고 둘째 자원 ID를 얻는다면 순서대로 할당하기 어렵다(?)



### 다중 스레드 코드 테스트

수억번을 돌린다면 드물게 발생하는 버그를 안정적으로 발견할 수는 있겠지만,, 복잡한 문제일 수록 어떻게 테스트를 많이 돌리기는 쉽지 않다

#### 몬테 카를로 테스트

* 조율이 가능하게 유연한 테스트를 만들고, 임의로 값을 조쥴하면서 반복해서 테스트를 돌린다
* 테스트가 실패한 조건은 신중하게 기록

#### 시스템을 배치할 플랫폼 전부에서 테스트를 돌리고, 돌고 계속해서 돌린다

* 테스트가 실패없이 오래 돌아간다면
  * 실제 코드가 올바르거나
  * 테스트가 부족해서 문제를 드러내지 못하고 있다는 의미!

#### 부하가 변하는 장비에서 테스트를 돌린다&#x20;

* 실제 환경과 비슷하게 부하를 걸어줄 수 있다면 그렇게 하기

#### 스레드 코드 테스트를 도와주는 도구

IBM - ConTest



### 결론

동시성 프로그래밍은 어렵다!



