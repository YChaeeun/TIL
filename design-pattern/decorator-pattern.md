# 데코레이터 패턴 Decorator Pattern

### 데코레이터 패턴 Decorator Pattern (Wrapper)

* 객체에 추가 요소를 동적으로 더할 수 있습니다 (동적으로 새로운 책임을 추가)
* 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있습니다
* 이때, 데코레이터는 자신이 장식하고 있는 개체에게 어떤 행동을 위임하는 일 말고도 추가 작업을 수행할 수 있다

### 다이어그램

<figure><img src="../.gitbook/assets/© DecoratorBase.png" alt=""><figcaption></figcaption></figure>

* DecoratorBase는 Decorator가 Component의 형식을 유지하면서 확장할 수 있도록, Component를 상속받는다
* 형식만 상속 받으면 되기 때문에 Component는 인터페이스나 추상클래스로 만들면 된다 (단, Component는 가볍게 정의해야한다)\


### 사용하는 경우

* 동적으로 또는 투명하게(다른 객체에 영향을 주지 않고) 개개의 객체에 새로운 책임을 추가하기 위해 사용
* 제거될 수 있는 책임에 대해 사용
* 실제 상속으로 서브클래스를 계속 만드는 방법이 실질적적이지 못할 때 사용(너무 많은 조합이 가능할 때)

### 디자인 패턴

#### OCP (Opened-Closed Principle)

* 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 한다
* 단, 무조건 OCP 를 적용할 경우 필요이상으로 복잡하고 이해하기 힘든 코드를 만들어서 시간을 낭비하게 될 수 있으므로 확장해야 할 부분을 세심하게 결정해야 한다

### 장점

* 단순 상속보다 설계의 융통성을 더 많이 증대시킬 수 있다
* 필요한 비용만 그때 지불하는 방식이기 때문에, 상부측 클래스에 많은 기능들이 누적되는 상황을 막을 수 있다 (필요한 추가 기능이 생겼을 때 그냥 새로운 장식자를 추가하면 끝!)

### 단점

* 규모가 작은 객체의 개수가 너무 많이 생길 수 있다 -> 각 객체들을 이해하고 수정하는 과정이 매우 복잡할 수도



### 데코레이터 패턴과 전략 패턴

* 객체의 겉포장을 변경할 것인가(데코레이터패턴) vs 속을 변경할 것인가(전략패턴)
