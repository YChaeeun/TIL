# 옵저버 패턴 Observer Pattern

## 옵저버 패턴

* 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게연락이 가고 자동으로 내용이 갱신
* 일대다(one-to-many) 의존성을 정의
* One subject - multiple observer

> OCP\
> DIP

### 다이어그램

<figure><img src="../.gitbook/assets/스크린샷 2023-01-09 오후 3.21.14.png" alt=""><figcaption></figcaption></figure>

### 옵저버 패턴을 사용하는 상황

* 어떤 추상 개념이 두 가지 양상을 갖고 하나가 다른 하나에 종속적일 때, 각 양상을 별도의 객체로 캡슐화하여 이들 각각을 재사용할 수 있다
* 한 객체에 가해진 변경으로 다른 객체를 변경해야 하고, 프로그래머들은 얼마나 많은 객체들이 변경되어야 하는지 몰라도 될 때
* 어떤 객체가 다른 객체에게 자신의 변화를 통보할 수 있는데, 그 변화에 관심있어하는 객체들이 누구인지에 대한 가정없이도 그러한 통보가 될 때

### 장점

* 주제(Subject)와 옵저버(Observer)클래스간에 추상적인 결합도만이 존재 (느슨한 결합)

### 단점

* 불필요한 갱신이 일어날 수 있고, 옵저버가 많아지면 추적이 까다로울 수 있음

### 디자인 원칙

상호작용하는 객체 사이에는 가능하면 **느슨한 결합**을 사용해야 한다

### 느슨한 결합 Loose Coupling

* 느슨하게 결합된 객체는 의존은 하되, 다른 객체의 세세한 부분까지는 모르게 결합되어야 유연한 디자인을 만들 수 있다
* 객체들이 상호작용할 수는 있지만, 서로를 잘 모르는 관계를 의미
* 옵저버 패턴은 느슨한 결합을 보여주는 좋은 예!
  * 주제 subject는 옵저버가 무엇을 하는지 모름
  * 옵저버는 언제든지 새로 추가되고, 변경될 수 있음 (이때 주제는 변경될 필요가 없음)
  * 주제와 옵저버를 독립적으로 재사용 가능
  * 주제와 옵저버가 변경되어도 서로에게 영향을 미치지 않음

### 변경 사항을 줄까? 가져갈까?

* 푸시 : 주제 -> 옵저버로 데이터 보냄, 옵저버 클래스의 재사용성이 떨어짐 (옵저버가 필요한 게 뭔지를 파악하고 데이터를 넘겨주기 때문에)
* 풀 : 주제 <- 옵저버가 데이터 당겨옴, 옵저버가 직접 무엇이 변했는지 확인해야 해서 비효율적일 수 있음

시간이 지남에 따라 애플리케이션이 더 커지고 복잡해지므로, 쉽게 확장하기 위해서는 풀 방식이 더 낫다!\


### 누가 갱신을 trigger 해야 할까?

1. 주제가 변경되었을 때 notify() : 사용자가 신경쓰지 않아도 됨, 연산이 계속되어 여러 번 수정될 경우 비효율적
2. 사용자가 필요할 때 notify() : 갱신의 시작을 미룰 수 있어서 불필요한 수정이 일어나지 않음, 사용자가 추가행동을 정의해야 하는데 오류가 발생할 여지가 많음 (호출하는 걸 까먹거나, 수정을 누락하거나,, 등등)
