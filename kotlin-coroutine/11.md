# 11장 코루틴 스코프 함수

여러 개의 엔드포인트에서 데이터를 동시에 얻어야 하는 중단함수는 어떻게 구현해야할까?

## 코루틴 스코프 소개 이전에 사용한 방법들

#### 방법 1) 중단 함수에서 중단함수 호출하기

* 문제 - 작업이 동시에 진행되지 않으므로 1초 + 1초 = 2초나 걸림

```kotlin
suspend fun getUserProfile(): UserProfileData {
    val user = getUserData()                // (1초 후)
    val notifications = getNotifications() // (1초 후)
    
    return UserProfileData(
        user = user,
        notifications = notifications
    )
}
```

#### 방법 2) 동시 작업을 위해 async 로 래핑하기

`async` 는 스코프내에서 호출되어야 한다,, 하지만 그렇다고 `GlobalScope`를 사용하면 안된다

```kotlin
// 이렇게 구현하면 안돼!
suspend fun getUserProfile(): UserProfileData {
    val user = GlobalScope.async { getUserData() }              
    val notifications = GlobalScope.async { getNotifications() }
    
    return UserProfileData(
        user = user.await(),
        notifications = notifications.await()
    )
}
```

GlobalScope는 EmptyCoroutineContext를 가진 스코프 일 뿐이므로, 내부에서 async를 호출하면 몇몇 문제가 생길 수 있다

* 문제
  * async가 부모 코루틴과 아무런 관계가 없어지므로 취소될 수 없다 (부모가 취소되어도 async 내부 함수는 여전히 실행 중인 상태가 됨)
  * 부모 코루틴으로부터 스코프를 상속받지 않고 기본 디스패처에서 실행되며, 부모의 컨텍스트와 전혀 연관이 없다
  * 즉, 메모리 누수가 발생할 수 있고 & 테스트하기도 어려워진다

```kotlin
public object GlobalScope : CoroutineScope {
    override val coroutineContext: CoroutineContext
        get() = EmptyCoroutineContext
}

public object EmptyCoroutineContext : CoroutineContext, Serializable {
    private const val serialVersionUID: Long = 0
    private fun readResolve(): Any = EmptyCoroutineContext

    public override fun <E : Element> get(key: Key<E>): E? = null
    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R = initial
    public override fun plus(context: CoroutineContext): CoroutineContext = context
    public override fun minusKey(key: Key<*>): CoroutineContext = this
    public override fun hashCode(): Int = 0
    public override fun toString(): String = "EmptyCoroutineContext"
}
```

#### 방법 3) 스코프를 인자로 넘기기

* 장점 - 취소가 가능하고 적절한 단위 테스트를 추가할 수 있다
* 문제 - 스코프가 함수에서 함수로 전달되면서 예상하지 못한 부작용이 발생할 수 있다,,, 잠재적으로 위험!
  * async에서 예외가 발생하면 모든 스코프가 닫힐 수도 있음 (SupervisorJob이 아닌 경우)
  * 스코프에 접근하는 함수가 cancel 메서드로 스코프를 취소하는 등 스코프를 조작할 수도 있음

```kotlin
// 이렇게 구현하면 안돼!
suspend fun getUserProfile(
    scope: CoroutineScope
): UserProfileData {
    val user = scope.async { getUserData() }              
    val notifications = scope.async { getNotifications() }
    
    return UserProfileData(
        user = user.await(),
        notifications = notifications.await()
    )
}

// 이것도 안돼!
suspend fun CoroutineScope.getUserProfile(): UserProfileData {
    val user = async { getUserData() }              
    val notifications = async { getNotifications() }
    
    return UserProfileData(
        user = user.await(),
        notifications = notifications.await()
    )
}
```

* 잘못 구현한 예제

```kotlin
data class Details(val name: String, val followers: Int)
data class Tweet(val text: String)

fun getFollowersNumber(): Int =
    throw Error("Service exception")
    
suspend fun getUserName(): String {
    delay(500)
    return "chaeeun"
}

suspend fun getTweets(): List<Tweet> {
    return listOf(Tweet("Hello, world"))
}

// 잘못된 구현 방법!
// Ambiguous coroutineContext due to CoroutineScope receiver of suspend function 
suspend fun CoroutineScope.getUserDetails(): Details {
    val userName = async { getUserName() }
    val followersNumber = async { getFollowersNumber() }
    return Details(userName.await(), followersNumber.await())
}

fun main() = runBlocking {
    val details = try {
        getUserDetails() // 발생한 예외가 해당 async를 종료, 전체 스코프 종료로 이어짐
    } catch (e: Error) {
        null
    }
    
    val tweets = async { getTweets() } // 전체 스코프 종료되어 동작 안함
    println("User: $details")
    println("Tweets: ${tweets.await()}")
}

// 예외만 발생
```

## coroutineScope

스코프를 시작하는 중단 함수, 인자로 들어온 함수가 생성한 값을 반환한다

```kotlin
suspend fun <R> coroutineScope(block: suspend CoroutineScope.() -> R): R
```

* async나 launch와 다르게 coroutineScope의 본체는 리시버없이 곧바로 호출됨
* 새로운 코루틴을 생성, 새로운 코루틴이 끝날 때 까지 coroutineScope를 호출한 코루틴을 중단한다
* 생성된 스코프는 바깥의 스코프에서 coroutineContext를 상속받지만, 컨텍스트의 Job을 오버라이딩한다
  * 부모로 부터 컨텍스트를 상속받음
  * 자신의 작업을 끝내기 전까지 모든 자식을 기다림
  * 부모가 취소되면 자식들 모두를 취소함

```kotlin
fun main() = runBlocking {   
    val a = coroutineScope { 
        delay(1000)
        10
    }
    println("a is caculated")
    val b = coroutineScope {
        delay(1000)
        20
    }
    println(a) // 10
    println(b) // 20
}

// (1초 후)
// a is calculated
// (1초 후)
// 10
// 20
```

* 예) coroutineContext가 상속되고, coroutineScope는 모든 자식이 끝날 때까지 종료되지 않는다

```kotlin
suspend fun longTask() = coroutineScope {
    launch {
        delay(1000)
        val name = coroutineContext[CoroutineName]?.name
        println("[$name] Finished task 1")
    }
    
    launch {
        delay(2000)
        val name = coroutineContext[CoroutineName]?.name
        println("[$name] Finished task 2")
    }
}

fun main() = runBlocking(CoroutineName("Parent")) {
    println("Before")
    longTask() // coroutineScope를 호출한 코루틴은 중단되므로, 작업이 끝나고 나서야 After 출력됨
    println("After")
}

// Before
// (1초 후)
// [Parent] Finished task 1
// (1초 후)
// [Parent] Finished task 2
// After
```

* 예) 부모가 취소되면 아직 끝나지 않은 자식 코루틴도 전부 취소됨
  * 코루틴 빌더와 달리 스코프에서는 속한 자식에서 예외가 발생하면, 다른 모든 자식이 취소되고 예외가 다시 던져진다

```kotlin
suspend fun longTask() = coroutineScope {
    launch {
        delay(1000)
        val name = coroutineContext[CoroutineName]?.name
        println("[$name] Finished task 1")
    }
    
    launch {
        delay(2000)
        val name = coroutineContext[CoroutineName]?.name
        println("[$name] Finished task 2")
    }
}

fun main() = runBlocking {
    val job = launch(CoroutineName("Parent")) {
        longTask()
    }
    delay(1500)
    job.cancel()
}
```



```kotlin
data class Details(val name: String, val followers: Int)
data class Tweet(val text: String)

fun getFollowersNumber(): Int =
    throw Error("Service exception")
    
suspend fun getUserName(): String {
    delay(500)
    return "chaeeun"
}

suspend fun getTweets(): List<Tweet> {
    return listOf(Tweet("Hello, world"))
}

// 위 잘못된 구현 예시의 해결 방법
suspend fun getUserDetails(): Details = coroutineScope {
    val userName = async { getUserName() }
    val followersNumber = async { getFollowersNumber() }
    return Details(userName.await(), followersNumber.await())
}

fun main() = runBlocking {
    val details = try {
        getUserDetails()
    } catch (e: Error) {
        null
    }
    
    val tweets = async { getTweets() }
    println("User: $details")
    println("Tweets: ${tweets.await()}")
}

// 예외
// Tweets: [Tweet(text=Hello, world)]
```

