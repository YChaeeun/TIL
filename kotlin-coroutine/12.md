# 12장 디스패처

## 기본 디스패처 Dispatchers.Default

* 디스패처를 설정하지 않으면 기본적으로 설정되는 디스패처
  * 단, runBlocking 은 디폴트로 Dispatchers.Default가 아닌 자신만의 디스패처를 사용함
* CPU 집약적인 연산을 수행하도록 설계됨
* 코드가 실행되는 컴퓨터의 CPU 개수와 동일한 수의 스레드 풀을 가지고 있다 (이론적으로는 최적의 스레드 수)

```kotlin
suspend fun main() = coroutineScope { // runBlocking 인 경우, `main` 에서 실행됨
    repeat(1000) {
        launch {
            List(1000) { Random.nextLong() }.maxOrNull()
            
            val threadName = Thread.currentThread.name
            println("Running on thread: $threadName")
        }
    }
}

//  CPU 개수만큼 출력됨
```

### 디스패처 스레드 제한하기 - limitedParallelism

* 디스패처가 같은 스레드 풀을 사용하지만, 같은 시간에 특정 수 이상의 스레드를 사용하지 못하도록 제한
* ex) 비용이 많이 드는 작업이 Dispatchers.Default의 스레드를 다 써버려서, 같은 디스패처를 사용하는 다른 코루틴이 실행될 기회가 없어지는 경우

```kotlin
private val dispatcher = Dispatchers.Default.limitedParallelism(5) // kotlinx.coroutines 1.6
```

## 메인 디스패처 Dispatchers.Main

* 메인 스레드에서 코루틴을 실행할 때 사용
* 안드로이드에서 기본 디스패처로 주로 사용
* 주의! 메인 스레드가 블로킹 되면 전체 애플리케이션이 멈춘다

## IO 디스패처 Dispatchers.IO

* I/O 연산으로 스레드를 블로킹할 때 사용
* 시간이 오래 걸리는 I/O 이나 블로킹 함수가 있는 라이브러리가 있을 경우, 메인이나 기본 디스패처를 블로킹 할 수 없으므로 Dispatchers.IO를 사용
  * ex) SharedPreference

#### 같은 시간에 사용할 수 있는 스레드 개수

```kotlin
suspend fun main() = coroutineScope { // runBlocking 인 경우, `main` 에서 실행됨
    repeat(1000) {
        launch(Dispatchers.IO) {
            Thread.sleep(200)
            
            val threadName = Thread.currentThread.name
            println("Running on thread: $threadName")
        }
    }
}

// 64개 (또는 코어 개수가 더 많으면 해당 코어의 수)
```

#### 50개 이상의 스레드를 사용해서 1초만에 작업 끝

```kotlin
suspend fun main() {
    val time = measureTimeMillis {
        coroutineScope {
            repeat(50) {
                launch(Dispatchers.IO) {
                    Thread.sleep(1000)
                }
            }
        }
    }
    println(time) // ~1000
}
```

### Dispatchers.Default와 Dispatchers.IO는 같은 스레드 풀을 공유한다

* 최적화 측면에서 중요 - 스레드는 재사용되고, 다시 배분될 필요가 없다
* 단, 디스패처의 스레드 수는 각각 별개로 설정됨

#### 예) Dispatchers.Default로 실행하는 도중 withContext(Dispatcher.IO){...} 까지 도달한 경우

```kotlin
suspend fun main() = coroutineScope {
    launch(Dispatchers.Default) {
        println(Thread.cureentThread().name)
        
        withContext(Dispatchers.IO) {
            println(Thread.currentThread().name)
        }
    }
}

// (대부분) 같은 스레드로 실행됨, 이때 개수 한도는 Dispatcher.IO의 한도로 적용됨
// DefaultDispatcher-worker-2
// DefaultDispatcher-worker-2
```

Dispatchers.Default, Dispatchres.IO 둘 모두를 최대치로 사용하는 경우 > 활성화된 스레드의 개수는 스레드 한도 전부를 합친것 과 같음&#x20;

* ex) Dispatchers.IO 에서 64개의 스레드까지 사용 가능 / 8개의 코어를 가지고 있다면 공유 스레드 풀에서 활성화된 스레드는 72개 > 스레드 재활용 측면에서 효율적 ???

#### withContext(Dispatchers.IO) 로 래핑한 중단함수 만들기

* 이때 래핑한 중단함수가 너무 많은 스레드를 블로킹하면 문제가 될 수 있다! > 이런 경우에는 limitedParallelism 활용하기

```kotlin
class DiscUserRepository(
    private val discReader: DiscReader
): UserRepository {
    override suspend fun getUser(): UserData = 
        withContext(Dispatchers.IO) {
            UserData(discReader.read("userName"))
        }
}
```

### 커스텀 스레드 풀을 사용하는 IO 디스패처



```kotlin
suspend fun main() = coroutineScope {
    launch {
        printCoroutinesTime(Dispatchers.IO)
        // Dispatchers.IO took: 2074
    }
    
    launch {
        val dispatcher = Dispatchers.IO.limitedParallelism(100)
        printCoroutinesTime(dispatcher)
        // LimitedDispatcher@XXX took: 1082
    }
}

suspend fun printCoroutinesTime(
    dispatcher: CoroutineDispatcher
) {
    val test = measureTimeMillis {
        coroutineScope {
            repeat(100) {
                launch(dispatcher) {
                    Thread.sleep(1000)
                }
            }
        }
    }
    println("$dispatcher took: $test")
}
```



## 정해진 수의 스레드 풀을 가진 디스패처



## 싱글스레드로 제한된 디스패처



## 프로젝트 룸의 가상 스레드 사용하기



## 제한 받지 않는 디스패처



## 메인 디스패처로 즉시 옮기기



## 컨티뉴에이션 인터셉터



## 작업 종류에 따른 각 디스패처의 성능 비교





