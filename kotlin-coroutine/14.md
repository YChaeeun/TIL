# 14장 공유 상태로 인한 문제

```kotlin
class UserDownloader(
    private val api: NetworkService
) {
    private val users = mutableListOf<User>()
    
    fun downloaded() = users.toList() // 방어적 복사
    
    suspend fun fetchUser(id: Int) {
        val newUser = api.fetchUser(id)
        users.add(newUser)
    }
}
```

> 방어적 복사 - 객체 반환시 객체의 복사본을 만들어서 반환 / 복사한 외부의 객체를 변경해도 원본 내부 객체 변경되지 않음 (동일한 내부요소가 있을 경우 내부 요소의 참조값은 같다는 점에서 깊은 복사와는 다름)
>
> 얕은 복사 - 주소값 복사 / 원복, 복사한 객체 서로 영향을 미침 (call-by-reference와 비슷)
>
> 깊은 복사 - 원복 객체의 모든 값을 복사해서 원본 객체로부터 독립적인 객체 생성 / 복사본 완전 독립적 (call-by-value와 비슷)



```kotlin
class FackNetworkService: NetworkService {
    override suspend fun fetchUser(id: Int): User {
        delay(2)
        return User("User $id")
    }
}

suspend fun main() {
    val downloader = UserDownloader(FakeNetworkService())
    coroutineScope {
        repeat(1_000_000) {
            launch {
                downloader.fetchUser(it)
            }
        }
    }
    print(downloader.downloaded().size) // ~998242
}
```



```kotlin
var counter = 0

fun main() = runBlocking {
    massiveRun {
        counter++
    }
    println(counter)
}

suspend fun massiveRun(action: suspend () -> Unit) =
    withContext(Dispatchers.Default) {
        repeat(1000) {
            launch {
                repeat(1000) { action() }
            }
        }
    }
```



## 동기화 블로킹



```kotlin
var counter = 0

fun main() = runBlocking {
    val lock = Any()
    massiveRun {
        synchronized(lock) {
            counter++
        }
    }
    println("Counter = $counter") // 1000000
}
```



## 원자성



```kotlin
private var counter = AtomicInteger()

fun main() = runBlocking {
    massiveRun {
        counter.incrementAndGet()
    }
    println(counter.get())
}
```



```kotlin
class UserDownloader(
    private val api: NetworkService
) {
    private val users = AotmicReference(listOf<User>())
    
    fun downloaded() = users.get()
    
    suspend fun fetchUser(id: Int) {
        val newUser = api.fetchUser(id)
        users.getAndUpdate { it + newUser }
    }
}
```



## 싱글 스레드로 제한된 디스패처



```kotlin
val dispatcher = Dispatchers.IO.limitedParallelism(1)

var counter = 0

fun main() = runBlocking {
    massiveRun {
        withContext(dispatcher) {
            counter++
        }
    }
    println(counter) // 1000000
}
```



```kotlin
class UserDownloader(
    private val api: NetworkService
) {
    private val users = mutableListOf<User>()
    private val dispatcher = Dispatchers.IO.limitedParallelism(1)
    
    suspend fun downloaded() = 
        withContext(dispatcher) {
            users.toList()
        }
    
    suspend fun fetchUser(id: Int) = withContext(dispatcher) {
        val newUser = api.fetchUser(id)
        users += newUser
    }
}
```



```kotlin
class UserDownloader(
    private val api: NetworkService
) {
    private val users = mutableListOf<User>()
    private val dispatcher = Dispatchers.IO.limitedParallelism(1)
    
    suspend fun downloaded() = 
        withContext(dispatcher) {
            users.toList()
        }
    
    suspend fun fetchUser(id: Int) {
        val newUser = api.fetchUser(id)
        withContext(dispatcher) {
            users += newUser
        } 
    }
}
```



## 뮤텍스



```kotlin
suspend fun main() = coroutineScope {
    repeat(5) {
        launch {
            delayAndPrint()
        }
    }
}

val mutex = Mutext()

suspend fun delayAndPrint() {
    mutex.lock()
    delay(1000)
    println("Done")
    mutex.unlock()
}

// (1초 후)
// Done
// (1초 후)
// Done
// (1초 후)
// Done
// (1초 후)
// Done
```



```kotlin
val mutex = Mutex()

var counter = 0

fun main() = runBlocking {
    massiveRun {
        mutex.withLock {
            counter++
        }
    }
    println(counter) // 1000000
}
```



```kotlin
suspend fun main() {
    val mutex = Mutex()
    println("Started")
    
    mutex.withLock {
        mutex.withLock {
            println("will never be printed")
        }
    }
}

// Started
// (영원히 실행)
```



```kotlin
class MessageRepository {
    private val messages = mutableListOf<String>()
    private val mutex = Mutex()
    
    suspend fun add(message: String) = mutex.withLock {
        delay(1000)
        messages.add(message)
    }
}

suspend fun main() {
    val repo = MessagesRepository()
    
    val timeMillis = measureTimeMillis {
        coroutineScope {
            repeat(5) {
                launch {
                    repo.add("Message $it")
                }
            }
        }
    }
    println(timeMillis) // ~5120
}
```



## 세마포어



```kotlin
suspend fun main() = coroutineScope {
    val semaphore = Semaphore(2)
    
    repeat(5) {
        launch {
            semaphore.withPermit {
                delay(1000)
                print(it)
            }
        }
    }
}

// 01
// (1초 후)
// 23
// (1초 후)
// 4
```



```kotlin
class LimitedNetworkUserRepository(
    private val api: UserApi
) {
    private val semaphore = Semaphore(10)
    
    suspend fun requestUser(userId: String) = 
        semaphore.withPermit {
            api.requestUser(userId)
        }
}
```

