# 18장 핫 데이터 소스와 콜드 데이터 소스

* 핫 - 컬렉션(List, Set) / Channel
* 콜드 - Sequence, Stream / Flow, RxJava 스트림

## 핫 vs 콜드

* 핫 - 데이터를 소비하는 것과 무관하게 원소를 생성
  * 항상 사용 가능한 상태 (각 연산이 최종 연산이 될 수 있다)
  * 여러 번 사용되었을 때 매번 결과를 다시 계산할 필요가 없다
* 콜드 - 요청이 있을 때만 작업을 수행하며 아무것도 저장하지 않음
  * 무한할 수 있다
  * 최소한의 연산만 수행한다
  * (중간에 생성되는 값들을 보관할 필요가 없기 때문에) 메모리를 적게 사용한다

#### 핫  vs 콜드 데이터 실행 시점

* 핫 데이터 스트림의 빌더와 연산은 즉각 실행&#x20;
* 콜드 데이터 스트림에서는 원소가 필요할 때까지 실행 되지 않는다

```kotlin
fun main() {
    val l = buildList {
        repeat(3) {
            add("User$it")
            println("L: Added User")
        }
    }
    
    val l2 = l.map {
        println("L: Processing")
        "Processed $it"
    }
    
    val s = sequence {
        repeat(3) {
            yield("User$it")
            println("S: Added User")
        }
    }
    
    val s2 = s.map {
        println("S: Processing")
        "Processed $it"
    }
    
    // 콜드 데이터스트림 원소 사용
 // for (ss in s2) {
 //       println(ss)
 //   }
}

// L: Added User
// L: Added User
// L: Added User
// L: Processing
// L: Processing
// L: Processing
```

#### 핫 vs 콜드 순서가 다른 처리 방식

콜드 - 원소를 지연처리 하기 때문에 더 적은 연산을 수행한다

리스트는 원소의 컬렉션 but 시퀀스는 원소를 어떻게 계산할지 정의한 것에 불과

```kotlin
fun m(i: Int): Int {
    print("m$i ")
    return i * i
}

fun f(i: Int): Boolean {
    print("f$i ")
    return i >= 10
}

fun main() {
    listOf(1,2,3,4,5,6,7,8,9,10)
        .map { m(it) }
        .find { f(it) }
        .let { print(it) }
    // m1 m2 m3 m4 m5 m6 m7 m8 m9 m10 f1 f4 f9 f16 16
    
    println()
    
    sequenceOf(1,2,3,4,5,6,7,8,9,10)
        .map { m(it) }
        .find { f(it) }
        .let { print(it) }
    // m1 f1 m2 f4 m3 f9 m4 f16 16
}
```



```kotlin
fun m(i: Int): Int {
    print("m$i ")
    return i * i
}

fun main() {
    val l = listOf(1,2,3,4,5,6,7,8,9,10)
        .map { m(it) } // m1 m2 m3 m4 m5 m6 m7 m8 m9 m10
        
    println(l) // [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
    
    println(l.find { it > 10 }) // 16
    println(l.find { it > 10 }) // 16
    println(l.find { it > 10 }) // 16
    
    val s = sequenceOf(1,2,3,4,5,6,7,8,9,10)
        .map { m(it) }
        
    println()
    println(s.toList()) // m1 m2 m3 m4 m5 m6 m7 m8 m9 m10 [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
    
    println(s.find { it > 10 })
    println(s.find { it > 10 })
    println(s.find { it > 10 })
}
```



## 핫 채널, 콜드 플로우



```kotlin
val channel = produce {
    while(true) {
        val x = computeNextValue()
        send(x)
    }
}

val flow = flow {
    while(true) {
        val x = computeNextValue()
        exmit(X)
    }
}
```



```kotlin
private fun CoroutineScope.makeChannel() = produce {
    println("Channel started")
    for (i in 1..3) {
        delay(1000)
        send(i)
    }
}

suspend fun main() = coroutineScope {
    val channel = makeChannel()
    
    delay(1000)
    println("Calling channel")
    for (value in channel) {
        println(value)
    }
    println("Consuming again...")
    for (value in channel) {
        println(value)
    }
}

// Channel started
// (1초 후)
// Calling channel...
// (1초 후)
// 1
// (1초 후)
// 2
// (1초 후)
// 3
// Consuming again...
```



```kotlin
private fun makeFlow() = flow {
    println("Flow started")
    for (i in 1..3) {
        delay(1000)
        emit(i)
    }
}

suspend fun main() = coroutineScope {
    val flow = makeFlow()
    
    delay(1000)
    println("Calling flow...")
    flow.collect { value -> println(value) }
    println("Consuming again...")
    flow.collect { value -> println(value) }
}

// (1초 후)
// Calling flow...
// Flow started
// (1초 후)
// 1
// (1초 후)
// 2
// (1초 후)
// 3
// Consuming again...
// Flow started
// (1초 후)
// 1
// (1초 후)
// 2
// (1초 후)
// 3
```



