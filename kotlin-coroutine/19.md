# 19장 플로우란 무엇인가?



```kotlin
interface Flow<out T> {
    suspend fun collect(collector: FlowCollector<T>)
}
```



```kotlin
interface Iterable<out T> {
    operator fun iterator(): Iterator<T>
}

interface Sequence<out T> {
    operator fun iterator(): Iterator<T>
}
```



## 플로우와 값들을 나타내는 다른 방법들의 비교



```kotlin
fun allUsers(): List<User> = 
    api.getAllUsers().map { it.toUser() }
```



```kotlin
fun getList(): List<Int> = List(3) {
    Thread.sleep(1000)
    "User$it"
}

fun main() {
    val list = getList()
    println("Function started")
    list.forEach { println(it) }
}

// (3초 후)
// Function started
// User0
// User1
// User2
```





```kotlin
fun getSequence(): Sequence<String> = sequence {
    repeat(3) {
        Thread.sleep(1000)
        yeild("User$it")
    }
}

fun main() {
    val list = getSequence()
    println("Function started")
    list.forEach { println(it) }
}

// Function started
// (1초 후)
// User0
// (1초 후)
// User1
// (1초 후)
// User2
```



```kotlin
fun getSequence(): Sequence<String> = sequence {
    repeat(3) {
        delay(1000) // 컴파일 에러 발생
        yeild("User$it")
    }
}
```





```kotlin
fun allUsersSequence(
    api: UserApi
): Sequence<User> = sequence {
    var page = 0
    do {
        val users = api.takePage(page++) // 중단 함수, 컴파일 에러 발생
        yieldAll(users)
    } while(!users.isNullOrEmpty())
}
```



```kotlin
val fibonacci = sequence {
    var first = 0.toBigInteger()
    var second = 1.toBigInteger()
    while(true) {
        yield(first)
        val temp = first
        first += second
        second = temp
    }
}

fun countCharactersInFile(path: String) =
    File(path).useLines { lines ->
        lines.sumBy { it.length }
    }
```



```kotlin
fun getSequence = sequence {
    repeat(3) {
        Thread.sleep(1000) // delay(1000)과 같은 결과
        yield("User$it")
    }
}

suspend fun main() {
    withContext(newSingleThreadContext("main")) {
        launch {
            repeat(3) {
                delay(100)
                println("Processing on coroutine")
            }
        }
        
        val list = getSequence()
        list.forEach { println(it) }
    }
}

// (1초 후)
// User0
// (1초 후)
// User1
// (1초 후)
// User2
// Processing on coroutine
// (0.1초 후)
// Processing on coroutine
// (0.1초 후)
// Processing on coroutine
```





```kotlin
fun getFlow() = flow {
    repeat(3) {
        delay(1000)
        emit("User$it")
    }
}

suspend fun main() {
    withContext(newSingleThreadContext("main")) {
        launch {
            repeat(3) {
                delay(100)
                println("Processing on coroutine")
            }
        }
        
        val list = getFlow()
        list.collect { println(it) }
    }
}

// (0.1초 후)
// Processing on coroutine
// (0.1초 후)
// Processing on coroutine
// (0.1초 후)
// Processing on coroutine
// (1 - 3*0.1 = 0.7초 후)
// User0
// (1초 후)
// User1
// (1초 후)
// User2
```



```kotlin
fun allUsersFlow(
    api: UserApi
) = flow {
    var page = 0
    do {
        val users = api.takePage(page++)
        emitAll(users)
    } while (!users.isNullOrEmpty())
}
```



## 플로우의 특징



```kotlin
fun usersFlow() = flow {
    repeat(3) {
        delay(1000)
        val ctx = currentCoroutineContext()
        val name = ctx[CoroutineName]?.name
        emit("User$it in $name")
    }
}

suspend fun main() {
    val users = usersFlow()
    
    withContext(CoroutineName("Name")) {
        val job = launch {
            users.collect { println(it) }
        }
        
        launch {
            delay(2100)
            println("I got enough")
            job.cancel()
        }
    }
}

// (1초 후)
// User0 in Name
// (1초 후)
// User0 in Name
// (0.1초 후)
// I got enough
```



## 플로우 명명법





## 실제 사용 예



```kotlin
suspend fun getOffers(
    sellers: List<Seller>
) = coroutineScope {
    sellers
        .map { seller ->
            async { api.requestOffers(seller.id)
        }
        .flatMap { it.awiat() }
}
```



```kotlin
suspend fun getOffers(
    sellers: List<Seller>
) = sellers
        .asFlow()
        .flatMapMerge(concurrency = 20) { seller ->
                suspend { api.requestOffers(seller.id) }.asFlow()
        }
        .toList()
}
```

