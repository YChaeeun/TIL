# 20장 플로우의 실제 구현

## Flow 이해하기

```kotlin
suspend fun main() {
    val f: suspend () -> Unit = {
        print("A")
        delay(1000)
        print("B")
        delay(1000)
        print("C")
    }
    
    f()
    f()
}

// A
// (1초 후)
// B
// (1초 후)
// C
// A
// (1초 후)
// B
// (1초 후)
// C
```

#### emit 이라는 함수를 나타내는 파라미터 가지기&#x20;

```kotlin
suspend fun main() {
    val f: suspend((String) -> Unit) -> Unit = { emit ->
        emit("A")
        emit("B")
        emit("C")
    }
    
    f {
         print(it) // f 내부에서 emit 으로 사용됨 
    } // ABC
    f { print(it) } // ABC
}
```

#### emit이라는 추상 메서드를 가진 FlowCollector 함수형 인터페이스 정의해서 간단하게 표현해보기

```kotlin
import kotlin.*

fun interface FlowCollector {
    suspend fun emit(value: String)
}

suspend fun main() {
    val f: suspend (FlowCollector) -> Unit = {
        it.emit("A")
        it.emit("B")
        it.emit("C")
    }
    
    f { print(it) } // ABC
    f { print(it) } // ABC
}
```

#### FlowCollector 리시버로 만들기

```kotlin
fun interface FlowCollector {
    suspend fun emit(value: String)
}

suspend fun main() {
    val f: suspend FlowCollector.() -> Unit = {
        emit("A") // it 에서 호출하는 부분 제거
        emit("B")
        emit("C")
    }
    
    f { print(it) } // ABC
    f { print(it) } // ABC
}
```

#### 람다식 대신 인터페이스를 구현한 객체 만들기

인터페이스를 Flow 라고 하고, 해당 인터페이스의 정의는 객체 표현식으로 래핑

```kotlin
fun interface FlowCollector {
    suspend fun emit(value: String)
}

interface Flow {
    suspend fun collect(collector: FlowCollector)
}

suspend fun main() {
    val builder: suspend FlowCollector.() -> Unit = {
        emit("A")
        emit("B")
        emit("C")
    }

    val flow: Flow = object: Flow {
        override suspend fun collect(collector: FlowCollector) {
            collector.builder()
        }
    }
    
    flow.collect { print(it) } // ABC
    flow.collect { print(it) } // ABC
}
```

#### flow 빌더 정의하기

```kotlin
fun interface FlowCollector {
    suspend fun emit(value: String)
}

interface Flow {
    suspend fun collect(collector: FlowCollector)
}

fun flow(builder: suspend FlowCollector.() -> Unit) =
    object: Flow {
        override suspend fun collect(collector: FlowCollector) {
            collector.builder()
        }
    }

suspend fun main() {
    val f: Flow = flow {
        emit("A")
        emit("B")
        emit("C")
    }
    
    flow.collect { print(it) } // ABC
    flow.collect { print(it) } // ABC
}
```

#### 제네릭 타입으로 바꾸기

실제 Flow, FlowCollector, flow 와 비슷한 구현

```kotlin
fun interface FlowCollector<T> {
    suspend fun emit(value: T)
}

interface Flow<T> {
    suspend fun collect(collector: FlowCollector<T>)
}

fun <T> flow(builder: suspend FlowCollector<T>.() -> Unit) =
    object: Flow<T> {
        override suspend fun collect(collector: FlowCollector<T>) {
            collector.builder()
        }
    }

suspend fun main() {
    val f: Flow<String> = flow {
        emit("A")
        emit("B")
        emit("C")
    }
    
    flow.collect { print(it) } // ABC
    flow.collect { print(it) } // ABC
}
```



## Flow 처리 방식

* 새로운 플로우를 만들기 위해 flow 빌더를 사용
* 플로우가 시작되면 래핑하고 있는 플로우를 시작 > 빌더 내부에서 collect 메서드 호출

```kotlin
fun <T, R> Flow<T>.map(
    transformation: suspend (T) -> R
): Flow<R> = 
    flow {
        collect {
            emit(transformation(it))
        }
    }

suspend fun main() {
    flowOf("A", "B", "C")
        .map {
            delay(1000)
            it.lowercase()
        }
        .collect { println(it) }
}

// (1초 후)
// a
// (1초 후)
// b
// (1초 후)
// c
```

#### 비슷한 작동 방식의 함수들 작성하기

```kotlin
fun <T> Flow<T>.filter(
    predicate: suspend (T) -> Boolean
) = flow {
        collect {
            if (predicate(it)) {
                emit(it)
            }
        }
    }

fun <T> Flow<T>.onEach(
    action: suspend (T) -> Unit
) = flow {
        collect {
            action(it)
            emit(it)
        }
    }

fun <T> Flow<T>.onStart(
    action: suspend () -> Unit
) = flow {
        action()
        collect {
            emit(it)
        }
    }
```



## 동기로 작동하는 Flow

* 플로우가 완료될 때까지 collect 호출이 중단된다 (즉, 플로우는 새로운 코루틴을 시작하지 않는다)
* 각각의 처리 단계는 동기적으로 실행

```kotlin
suspend fun main() {
    flowOf("A", "B", "C")
        .onEach { delay(1000) } // 동기적으로 실행되므로 각 원소 사이에 지연 발생
        .collect { println(it) }
}

// (1초 후)
// A
// (1초 후)
// B
// (1초 후)
// C
```



## 플로우와 공유 상태

#### 동기로 동작하기 때문에 별도의 동기화 없이도 플로우 내부에 변경 가능한 상태를 정의할 수 있다

```kotlin
fun <T, K> Flow<T>.distinctBy(
    keySelector: (T) -> K
) = flow {
    val sentKeys = mutableSetOf<K>()
    collect { value ->
        val key = keySelector(value) // 변경 가능한 상태 정의
        if (key !in sentKeys) {
            sentKeys.add(key)
            emit(value)
        }
    }
}
```

#### 일정한 결과값을 생성

```kotlin
fun Flow<*>.counter() = flow<Int> {
    var counter = 0
    collect {
        counter++
        List(100) { Random.nextLong() }.shuffled().sorted() // 잠깐동안 바쁘게 만들기(?)
        emit(counter)
    }
}

suspend fun main() = coroutineScope {
    val f1 = List(1000) { "$it" }.asFlow()
    val f2 = List(1000) { "$it" }.asFlow().counter()
    
    launch { println(f1.counter().last()) } // 1000
    launch { println(f1.counter().last()) } // 1000
    launch { println(f2.last()) } // 1000
    launch { println(f2.last()) } // 1000
}
```

#### 주의! 플로우 단계의 외부 변수를 추출할 경우 별도의 동기화 과정 필요

외부 변수는 같은 플로우가 모으는 모든 코루틴이 공유한다(?)

* 같은 플로우를 collect 하는 모든 코루틴이 외부 변수를 공유한다?

```kotlin
fun Flow<*>.counter(): Flow<Int> {
    var counter = 0
    return this.map { // 외부 변수로 추출
        counter++
        List(100) { Random.nextLong() }.shuffled().sorted()
        counter
    }
}

suspend fun main() = coroutineScope {
    val f1 = List(1_000) { "$it" }.asFlow()
    val f2 = List(1_000) { "$it" }.asFlow().counter() // 외부 변수로 추출, 공유
    
    launch { println(f1.counter().last()) } // 1000
    launch { println(f1.counter().last()) } // 1000
    
    // 2개의 코루틴이 병렬로 원소를 세게 됨
    launch { println(f2.last()) } // 2000 보다 작은 값
    launch { println(f2.last()) } // 2000 보다 작은 값
}
```



#### 주의2 - 플로우에서 동기화가 필요한 경우

* 플로우에서 사용하는 변수가 함수 외부, 클래스의 스코프, 최상위 레벨에서 정의되어 있는 경우 동기화가 필요하다

```kotlin
var counter = 0 // 최상위 레벨에서 정의된 변수

fun Flow<*>.counter(): Flow<Int> = this.map {
        counter++
        List(100) { Random.nextLong() }.shuffled().sorted()
        counter
    }

suspend fun main() = coroutineScope {
    val f1 = List(1_000) { "$it" }.asFlow()
    val f2 = List(1_000) { "$it" }.asFlow().counter() 
    
    // 4개의 코루틴이 병렬로 원소를 셈
    launch { println(f1.counter().last()) } // 4000 보다 작은 값
    launch { println(f1.counter().last()) } // 4000 보다 작은 값
    launch { println(f2.last()) } // 4000 보다 작은 값
    launch { println(f2.last()) } // 4000 보다 작은 값
}
```

