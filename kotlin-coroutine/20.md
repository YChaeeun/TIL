# 20장 플로우의 실제 구현



## Flow 이해하기



```kotlin
fun main() {
    val f = {
        print("A")
        print("B")
        print("C")
    }
    
    f() // ABC
    f() // ABC
}
```



```kotlin
suspend fun main() {
    val f = {
        print("A")
        delay(1000)
        print("B")
        delay(1000)
        print("C")
    }
    
    f()
    f()
}

// A
// (1초 후)
// B
// (1초 후)
// C
// A
// (1초 후)
// B
// (1초 후)
// C
```



```kotlin
suspend fun main() {
    val f: suspend((String) -> Unit) -> Unit = { emit ->
        emit("A")
        emit("B")
        emit("C")
    }
    
    f { print(it) } // ABC
    f { print(it) } // ABC
}
```



```kotlin
import kotlin.*

fun interface FlowCollector {
    suspend fun emit(value: String)
}

suspend fun main() {
    val f = {
        it.emit("A")
        it.emit("B")
        it.emit("C")
    }
    
    f { print(it) }
    f { print(it) }
}
```



```kotlin
fun interface FlowCollector {
    suspend fun emit(value: String)
}

suspend fun main() {
    val f: suspend FlowCollector.() -> Unit = {
        emit("A")
        emit("B")
        emit("C")
    }
    
    f { print(it) } // ABC
    f { print(it) } // ABC
}
```



## Flow 처리 방식

```kotlin
fun <T, R> Flow<T>.map(
    transformation: suspend (T) -> R
): Flow<R> = flow {
    collect {
        emit(transformation(it))
    }
}

suspend fun main() {
    flowOf("A", "B", "C")
        .map {
            delay(1000)
            it.lowercase()
        }
        .collect { println(it) }
}

// (1초 후)
// a
// (1초 후)
// b
// (1초 후)
// c
```



```kotlin
fun <T> Flow<T>.filter(
    predicate: suspend (T) -> Boolean
) = flow {
    collect {
        if (predicate(it)) {
            emit(it)
        }
    }
}

fun <T> Flow<T>.onEach(
    action: suspend (T) -> Unit
) = flow {
    collect {
        action(it)
        emit(it)
    }
}

fun <T> Flow<T>.onStart(
    action: suspend () -> Unit
) = flow {
    action()
    collect {
        emit(it)
    }
}
```



## 동기로 작동하는 Flow



```kotlin
suspend fun main() {
    flowOf("A", "B", "C")
        .onEach { delay(1000) }
        .collect { println(it) }
}

// (1초 후)
// A
// (1초 후)
// B
// (1초 후)
// C
```



## 플로우와 공유 상태



```kotlin
fun <T, K> Flow<T>.distinctBy(
    keySelector: (T) -> K
) = flow {
    val sentKeys = mutableSetOf<K>()
    collect { value ->
        val key = keySelector(value)
        if (key !in sentKeys) {
            sentKeys.add(key)
            emit(value)
        }
    }
}
```





```kotlin
fun Flow<*>.counter() = flow<Int> {
    var counter = 0
    collect {
        counter++
        List(100) { Random.nextLong() }.shuffled().sorted()
        emit(counter)
    }
}

suspend fun main() = coroutineScope {
    val f1 = List(1000) { "$it" }.asFlow()
    val f2 = List(1000) { "$it" }.asFlow().counter
    
    launch { println(f1.counter().last()) } // 1000
    launch { println(f1.counter().last()) } // 1000
    launch { println(f2.last()) } // 1000
    launch { println(f2.last()) } // 1000
}
```



```kotlin
fun Flow<*>.counter() {
    var counter = 0
    return this.map {
        counter++
        List(100) { Random.nextLong() }.shuffled().sorted()
        counter
    }
}

suspend fun main() = coroutineScope {
    val f1 = List(1_000) { "$it" }.asFlow()
    val f2 = List(1_000) { "$it" }.asFlow().counter
    
    launch { println(f1.counter().last()) } // 1000
    launch { println(f1.counter().last()) } // 1000
    launch { println(f2.last()) } // 1000
    launch { println(f2.last()) } // 1000

}
```

