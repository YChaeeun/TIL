# 4장 코루틴의 실제 구현

## 컨티뉴에이션 전달 방식 continuation-passing style

* Continuation 은 함수에서 함수로, 인자를 통해 전달됨

```kotlin
suspend fun getuser(): User?
suspend fun setUser(user: User)
suspend fun checkAvailability(flight: Flight) : Boolean

fun getUser(continuation: Continuation<*>): Any?
fun setUser(user: User, continuation: Continuation<*>): Any?
fun checkAvailiability(flight: Flight, continuation: Continuation<*>): Any?
```

* 반환타입이 Any 또는 Any?로 변경됨 > 중단 함수 실행 중에 중단될 경우, 선언된 타입의 값을 반환하지 않을 수도 있기 때문
  * 나중에 코틀린에서 `User? | COROUTINE_SUSPEND` 같은 유니언 타입을 도입할지도
* 타입의 값 대신 COROUTINE\_SUSPEND 라는 특별한 마커를 반환한다

## 예제

```kotlin
suspend fun myFunction() {
    println("Before")
    delay(1000)
    println("After")
}

// 시그니처 추론해보면,,
fun myFunction(continuation: Continuration<*>): Any
```

* 함수의 상태를 저장하기 위해 자신만의 Continuation 객체가 필요하다
* 클래스에 포장이 없는 경우에만 포장을 해야 한다
  * 코루틴이 실행되고 있으면, Continuation 객체는 이미 래핑되어 있을 것이므로 Continuation 객체를 그대로 둬야한다

<pre class="language-kotlin"><code class="lang-kotlin"><strong>// 이해를 위해 MyContinuation 이라는 이름을 붙임
</strong><strong>val continuation = MyFunctionContinuation(continuation)
</strong>
// 클래스에 포장이 없는 경우에만 포장하기
val continuation = if (continutation is MyFunctionContinuation) continuation else MyContinuation(continuation)

// 간단하게 표현
val continution = (continuation as? MyFunctionContinuation) ?: MyFunctionContinuation(continuation)
</code></pre>



#### myFunction의 시작점과 세부 구현

* 현재 상태를 저장하기 위해 label 이라는 필드를 사용
* 만약 delay 호출이 COROUTINE\_SUSPEND 대신 Unit 을 반환했다면?
  * 중단되지 않고 다른 함수와 동일하게 동작할 것

```kotlin
suspend fun myFunction() {
    // 함수의 시작점
    println("Before")
    delay(1000) // 중단 함수
    // 함수 재개 시점 (Continuation 이 resume을 호출할 때)
    println("After")
}

// 세부 구현
fun myFunction(continuation: Continuation<Unit>: Any {
    val continution = (continuation as? MyFunctionContinuation) ?: MyFunctionContinuation(continuation)

    if (continuation.label == 0) {
        println("Before")
        continuation.label = 1 // 상태 업데이트
        if (delay(1000, continuation) == COROUTINE_SUSPEND) {
            return COROUTINE_SUSPEND
        }
    }
    
    if (continuation.label == 1) {
        println("After")
        return Unit
    }
    
    error("Impossible")
}

```



#### 익명 클래스로 구현된 Continuation 객체

* JVM에서는 컴파일한 후 타입 인자가 지워지기 때문에 타입은 신경쓰지 않아도 됨!

```kotlin
cont = object: ContinuatinImpl(continuation) {
    var result: Any? = null
    var label = 0
    
    override fun invokeSuspend(`$result`: Any?): Any? {
        this.result = `$result`;
        return myFunction(this);
    }
}
```

### 예제 최종 세부 구현 코드

```kotlin
suspend fun myFunction() {
    // 함수의 시작점
    println("Before")
    delay(1000) // 중단 함수
    // 함수 재개 시점 (Continuation 이 resume을 호출할 때)
    println("After")
}

// 세부 구현
fun myFunction(continuation: Continuation<Unit>: Any {
    val continution = (continuation as? MyFunctionContinuation) ?: MyFunctionContinuation(continuation)

    if (continuation.label == 0) {
        println("Before")
        continuation.label = 1 // 상태 업데이트
        if (delay(1000, continuation) == COROUTINE_SUSPEND) {
            return COROUTINE_SUSPEND
        }
    }
    
    if (continuation.label == 1) {
        println("After")
        return Unit
    }
    
    error("Impossible")
}

class MyFunctionContinuation(val completion: Continuation<Unit>): Continuation<Unit> {
    override val context: CoroutineContext
        get() = completion.context
        
    var label = 0
    var result: Result<Any>? = null
    
    override fun resumeWith(result: Result<Unit>) {
        this.result = result
        val res = try {
        
        } catch(e: Throwable) {
        
        }
        completion.resumeWith(res)
    }
}
```
