# 6장 코루틴 빌더

* 중단 함수는 Conitnuation 객체를 다른 중단 함수로 전달해야하기 때문에, 일반 함수가 중단 함수를 호출하는 것은 불가능하다!
* 모든 중단 함수는 또 다른 중단 함수에 의해 호출되어야 함
* 코루틴 빌더&#x20;
  * 중단 함수를 연속으로 호출하면 시작되는 지점
  * 일반 함수와 중단 가능한 세계를 연결시키는 다리 역할
  * `launch` / `runBlocking` / `async`

## launch 빌더

* CoroutineScope 인터스의 확장 함수&#x20;

```kotlin
fun main() {
    GlobalScope.launch {
        delay(1000L)
        println("World")
    }
    
    GlobalScope.launch {
        delay(1000L)
        println("World")
    }
    
    GlobalScope.launch {
        delay(1000L)
        println("World")
    }
    
    println("Hello")
    Thread.sleep(2000L) // delay가 스레드를 블록시키지 않고 코루틴을 중단하기 때문에 
                        // 메인함수가 바로 종료되어버리는 것을 막기 위해 필요
}

// Hello
// (1초 후)
// World
// World
// World
```

## runBlocking&#x20;

* 블로킹이 필요할 때 사용
* 코루틴이 중단되었을 경우, runBlocking 빌더는 중단 메인 함수와 마찬가지로 시작한 스레드를 중단
* 사용하는 경우
  * 프로그램이 끝나는 걸 방지하기 위해 스레드를 블로킹할 필요가 있을 경우
  * 스레드를 블로킹할 필요가 있는 유닛 테스트 (runTest 를 주로 더 사용함)

```kotlin
fun main() {
    runBlocking {
        delay(1000L)
        println("World")
    }
    
    runBlocking {
        delay(1000L)
        println("World")
    }
    
    runBlocking {
        delay(1000L)
        println("World")
    }
    
    println("Hello")
}

// (1초 후)
// World
// (1초 후)
// World
// (1초 후)
// World
// Hello
```

```kotlin
fun main() = runBlocking {
    GlobalScope.launch {
        delay(1000L)
        println("World")
    }
    
    GlobalScope.launch {
        delay(1000L)
        println("World")
    }
    
    GlobalScope.launch {
        delay(1000L)
        println("World")
    }
    
    println("Hello")
    delay(1000L) // Thread.sleep() 대신 사용
}

// Hello
// (1초 후)
// World
// World
// World
```



## async 빌더

* launch와 비슷하게 호출되자마자 코루틴을 즉시 시작 &  값을 생성
  * 이 값은 마지막에 위치한 함수형의 인자에 의해 반환됨(람다 표현식)
  * 값이 필요 없을 때는 launch, 값이 필요할 때는 async를 사용하기
    * 값이 필요 없는데 async 사용하는 것은 권장하지 않음 (왜?)
* Deferred\<T> 타입의 객체 리턴, 이때 T 는 생성되는 값의 타입
  * await - Deferred에 있는 작업이 끝나면 값을 반환하는 중단 메서드
  * 값이 생성되면 해당 값을 내부에 저장하기 때문에 await에서 값이 반환되는 즉시 사용 가능
* 사용
  * 두 작업을 병렬로 실행할 때 주로 사용 (ex 두 가지 다른 곳에서 데이터를 얻어와 합치기)

```kotlin
fun main() = runBlocking {
    val resultDeferred: Deferred<Int> = GlobalScope.async {
        delay(1000L)
        42
    }
    
    val result: Int = resultDeferred.await() // (1초 후)
    println(result)
    
    println(resultDeferred.await()) // 간단하게 표현
}   
```

```kotlin
fun main() = runBlocking {
    val res1 = GlobalScope.async {
        delay(1000L)
        "1"
    }
    
    val res2 = GlobalScope.async {
        delay(3000L)
        "2"
    }
    
    val res3 = GlobalScope.async {
        delay(2000L)
        "3"
    }
    
    println(res1.await())
    println(res2.await())
    println(res3.await())
}

// (1초 후)
// 1
// (2초 후)
// 2
// 3
```

```kotlin
// 주의!
// 값이 필요 없는 데 async 사용하지 말 것
fun main() = runBlocking {
    GlobalScope.async {
        delay(1000L)
        println("world")
    }
    println("hello")
    delay(2000L)
}

```



## 구조화된 동시성
