# 7장 코루틴 컨텍스트

```kotlin
public interface CoroutineScope {
    public val coroutineContext: CoroutineContext
}

public interface Continuation<in T> {
    public val context: CoroutineContext
    public fun resumeWith(result: Result<T>)
}
```



## CoroutineContext 인터페이스

* 원소나 원소들의 집합을 나타내는 인터페이스
* 인덱싱된 집합으로, map, set 같은 컬랙션과 개념적으로 비슷
* 코루틴의 데이터를 객체로 그룹화하고, 저장, 전달하는 방법
  * 코루틴의 상태가 어떤지 확인하고, 어떤 스레드를 선택할지 등등 코루틴의 작동 방식을 정할 수 있음
  * ex) Job - 변경이 가능 / 코루틴의 자식과 부모가 소통하기 위해 사용하는 특별한 컨텍스트

```kotlin
public interface CoroutineContext {
    public operator fun <E : Element> get(key: Key<E>): E?
    public fun <R> fold(initial: R, operation: (R, Element) -> R): R
    
    
    public operator fun plus(context: CoroutineContext): CoroutineContext = {
        // ...
    }
    
    public fun minusKey(key: Key<*>): CoroutineContext
    public interface Key<E : Element> // 모든 원소는 식별할 수 있는 유일한 키를 가지고 있음
    
    public interface Element : CoroutineContext {
        // ...
    }
}
```

```kotlin
launch(CoroutineName("name1")) { ... }
launch(CoroutineName("name2" + Job()) { ... }

fun main() {
    val name: CoroutineName = CoroutineName("A name")
    val element: CoroutineContext.Element = name
    val context: CoroutineContext = element
    
    val job: Job = Job()
    val jobElement: CoroutineContext.Element = job
    val jobContext: CoroutineContext = jobElement
}
```

## CoroutineContext에서 원소 찾기 - get

```kotlin
fun main() {
    val ctx: CoroutineContext = CoroutineName("a name")
    
    val coroutineName: CoroutineName? = ctx[CoroutineName] // 원소 찾기
    // 또는 ctx.get(CoroutineName)
}
```

## 컨텍스트 더하기 - plus(+)

* 두 개의 CoroutineContext를 합쳐 하나의 CoroutineContext로 만들 수 있다

```kotlin
fun main() {
    val ctx1: CoroutineContext = CoroutineName("a name")
    val ctx2: CoroutinecContext = Job()
    
    val ctx3 = ctx1 + ctx2
}
```

* 같은 키를 가진 또 다른 원소가 더해지면, 새로운 원소가 기존 원소를 대체

```kotlin
fun main() {
    val ctx1: CoroutineContext = CoroutineName("name1")
    val ctx2: CoroutinecContext = CoroutineName("name2")
    
    val ctx3 = ctx1 + ctx2
    println(ctx3[CoroutineName]?.name) // name2
}
```

## 비어있는 코루틴 컨텍스트

* 컬렉션이므로 빈 컨텍스트를 만들 수 있지만, 다른 컨텍스트에 더해도 아무런 변화 없음!

```kotlin
fun main() {
    val empty: CoroutineContext = EmptyCoroutineContext
}
```

## 원소 제거 - minusKey

* minusKey 함수에 키를 넣음

```kotlin
fun main() {
    val ctx1 = CoroutineName("name1") + Job() // ctx1[CoroutineName]?.name - "name1"
    val ctx2 = ctx1.minusKey(CoroutineName) // ctx2[CoroutineName]?.name - null
    
    val ctx3 = (ctx1 + CoroutineName("name2")).minusKey(CoroutineName)
     // ctx3[CoroutineName]?.name - null
}
```

## 컨텍스트 폴딩 - fold

* 컨텍스트의 각 원소를 조작해야 하는 경우, 다른 컬렉션의 fold와 유사하게 사용 가능

```kotlin
fun main() {
    val ctx = CoroutineName("name1") + Job()
    ctx.fold("") { acc, element -> "$acc$element" }.also(::println)
    // CoroutineName(name1) JobImpl{Active}@dbbbb
    
    val empty = emptyList<CoroutineContext>()
    ctx.fold(empty) { acc, element -> acc + element }.joinToString().also(::println)
    // CoroutineName(name1) JobImpl{Active}@dbbbb
}
```

## 코루틴 컨텍스트와 빌더

* 부모는 기본적으로 컨텍스트를 자식에게 전달한다 (자식은 부모로부터 컨텍스트를 상속받는다)

```kotlin
fun CoroutineScope.log(msg: String) {
    val name = coroutineContext [CoroutineName] ?. name
    println(" [$name] $msg")
}
    
fun main() = runBlocking (CoroutineName("main")) {
    log ("Started") // [main] Started
    val v1 = async {
        delay (500)
        log ("Running async") // [mainl Running async
        42
    launch {
        delay (1000)
        log ("Running launch") // [main] Running launch
    ｝
    log ("The answer is ${v1. await ()}") // [main] The answer is 42
}
```

* 모든 자식은 빌더의 인자에서 정의된 특정 컨텍스트를 가질 수 있다 (인자로 전달된 컨텍스트는 부모로부터 상속받은 컨텍스트를 대체)
  * 해당 자식 스코프 내에서만 변경사항 적용

```kotlin
fun CoroutineScope.log(msg: String) {
    val name = coroutineContext [CoroutineName] ?. name
    println(" [$name] $msg")
}
    
fun main() = runBlocking (CoroutineName("main")) {
    log ("Started") // [main] Started
    
    val v1 = async(CoroutineName("c1")) {
        delay (500)
        log ("Running async") // [c1] Running async
        42
        
    launch(CoroutineName("c2")) {
        delay (1000)
        log ("Running launch") // [c2] Running launch
    ｝
    
    log ("The answer is ${v1.await()}") // [main] The answer is 42
}
```

* defaultContext + parentContext + childContext
  * 새로운 원소가 같은 키를 가진 이전 원소를 대체하므로, 상속받은 컨텍스트 중 같은 키를 가진 원소를 대체



## 중단 함수에서 컨텍스트에 접근하기

* coroutineScope는 컨텍스트를 접근할 때 사용하는 coroutineContext 프로퍼티를 가지고 있음
* 컨텍스트는 중단 함수 사이에 전달 되는 Continuation 객체가 참조하고 있음
* 즉, 중단 함수에서 부모의 컨텍스트에 접근 가능

```kotlin
suspend fun printName() {
    println(coroutineContext[CoroutineName]?.name)
}

suspend fun main() = withContext(CoroutineName("Outer")) {
    printName() // Outer
    launch(CoroutineName("Inner")) {
        printName() // Inner
    }
    delay(10)
    printName() // Outer
}
```



## 컨텍스트를 개별적으로 생성하기

* 일반적으로 커스텀하는 경우는 흔하지 않음
* CoroutineContext.Element 인터페이스를 구현하는 클래스 만들기
  * Key - 컨텍스트를 식별하는 키로, 필수적으로 필요

```kotlin
class MyCustomContext: CoroutineContext.Element {
    override val key: CoroutineContext.Key<*> = Key
    companion object Key : CoroutineContext.Key<MyCustomContext>
}
```

```kotlin
// 커스텀
class CounterContext(private val name: String) : CoroutineContext.Element {
    override val key: CoroutineContext. Key<*> = Key
    private var nextNumber = 0

    fun printNext () {
        println("$name: $nextNumber")
        nextNumber++
    }

    companion object Key: CoroutineContext.Key<CounterContext>
}

suspend fun printNext() {
    coroutineContext[CounterContext]?.printNext()
}

suspend fun main(): Unit =
    withContext (CounterContext ("Outer")) {
        printNext() // Outer: 0
        launch {
            printNext() // Outer: 1 
            launch {
                printNext() // Outer: 2
            }

            launch(CounterContext("Inner")) { // Key가 변경되었으므로 nextNumber값도 별도
                printNext() // Inner: 0
                printNext() // Inner: 1
                launch {
                    printNext() // Inner: 2
                }
            }
        }
        printNext() // Outer: 3
    }
    
// Outer: 0
// Outer: 1
// Outer: 2
// Outer: 3
// Inner: 0
// Inner: 1
// Inner: 2

// 자식에서 CounterContext("Inner") 지정하지 않은 경우
// Outer: 0
// Outer: 1
// Outer: 2
// Outer: 3
// Outer: 4
// Outer: 5
// Outer: 6
```
