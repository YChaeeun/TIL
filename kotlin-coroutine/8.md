# 8장 잡과 자식 코루틴 기다리기

## Job 이란?

* 수명을 가지고 있고 취소 가능한 컨텍스트
* 인터페이스지만, 구체적 사용법과 상태를 가지고 있는 추상 클래스처럼 사용 가능

```kotlin
interface Job : CoroutineContext.Element
```

## job의 상태

* NEW
  * 지연 시작되는 코루틴만 New 상태에서 시작됨
  * 작업이 실행되면 Active 상태가 된다
* ACTIVE
  * 대부분의 코루틴의 시작 상태
  * job이 실행되고 코루틴은 job을 수행함 (job이 코루틴 빌더에 의해 생성됨 > 코루틴 본체 실행)
  * _isActive = true_
* COMPLETITNG
  * job 실행이 완료된 상태
  * 자식들을 기다림
  * _isActive = true_
* COMPLETED
  * 자식들도 실행이 모두 끝난 상태
  * _isCompleted = true_
* CANCELLING
  * Active 또는 Completing 상태에서 취소 or 실패한 상태
  * 연결을 끊거나, 자원을 반납하는 등 후처리 작업을 할 수 있음
  * _isCancelled = true_
* CANCELLED
  * Cancelling 에서 후처리 작업을 완료한 상태
  * _isCancelled = true_
  * _isCompleted = true_

<figure><img src="../.gitbook/assets/스크린샷 2024-05-29 오후 5.24.06.png" alt=""><figcaption><p>job lifecycle</p></figcaption></figure>



## 코루틴 빌더는 부모의 job을 기초로 자신들의 job을 생성한다

* 모든 코루틴 빌더는 자신만의 job을 생성 & 반환 > 어느 곳에서든 사용할 수 있다
* launch - 명시적 반환 타입이 Job
* async - Deferred\<T> 또한 Job 인터페이스를 구현하고 있음

```kotlin
fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext, 
    start: CoroutineStart = CoroutineStart.DEFAULT, 
    block: suspend CoroutineScope.() -> Unit
): Job

fun <T> CoroutineScope.async(
    context: CoroutineContext = EmptyCoroutineContext, 
    start: CoroutineStart = CoroutineStart.DEFAULT, 
    block: suspend CoroutineScope.() -> T
): Deferred<T>

interface Deferred<out T> : Job
```

```kotlin
fun main(): Unit = runBlockking {
    val job = launch {
        delay(1000)
        println("Test")
    }
}
```

```kotlin
fun main() = runBlocking {
    val deferred = async {
        delay(1000)
        "Test"
    }    
    val job = deferred
}
```

* Job은 코루틴 컨텍스트이므로 coroutineContext\[Job]을 사용해서 접근 가능

```kotlin
val CoroutineContext.job: Job
    get() = get(Job) ?: error("Current context doesn't...")
    
val main() = runBlocking {
    print(coroutineContext.job.isActive)
}
```

* **코루틴이 상속하지 않는 유일한 코루틴 컨텍스트**
  * 자식 코루틴은 부모 코루틴으로부터 코루틴 컨텍스트를 상속받는데, job은 상속되지 않음
  * 부모와 자식 각각의 고유한 job을 가진다
* 모든 코루틴은 자신만의 Job을 생성 & 인자 또는 부모 코루틴으로부터 온 Job은 새로운 Job의 부모로 사용

```kotlin
fun main() = runBlocking {
    val name = CoroutineName("Some name")
    val job = Job()
    
    launch(name + job) {
        val childName = coroutineContext[CoroutineName]
        println(childName == name) // true
        
        val childJob = coroutineContext[Job] // child scope에서 생성한 job?
        println(childJob == job) // false 전달받은 job은 새로운 Job의 부모로 사용
        println(childJob == job.children.first()) // true
    }
}
```

* 부모 job와 자식 job 은 서로 참조 가능&#x20;

```kotlin
fun main() = runBlocking {
    val job = launch {
        delay(1000)
    }
    
    val parentJob = coroutineContext.job // coroutineContext[Job]
    println(job == parentJob) // false
    
    val parentChildren = prentJob.children
    println(parentChildren.first() == job) // true
}
```

* 새로운 Job 컨텍스트가 부모의 job을 대체하면 구조화된 동시성 작동 방식은 무효

```kotlin
fun main() = runBlocking {
    launch(Job()) { // 새로운 job이 부모로부터 상속받은 job을 대체
        delay(1000)
        println("will not be printed")
    }
}

// 프로그램 종료
// 구조화된 동시성이 제대로 작동했다면 부모 scope runBlocking이 자식인 launch 를 기다려줬을 것
// job이 대체되면서 부모-자식 관계가 성립하지 않게 됨
```



## 자식들 기다리기 - join

* join - 지정한 job이 Completed 나 Cancelled 같은 상태에 도달할 때까지 기다리는 중단함수

```kotlin
fun main() = runBlocking {
    val job1 = launch {
        delay(1000)
        println("Test1")
    }
    
    val job2 = launch {
        delay(2000)
        println("Test2")
    }
    
    job1.join()
    job2.join()
    println("All tests are done")
}

// (1초 후)
// Test1
// (2초 후)
// Test2
// All tests are done
```

* job 인터페이스는 모든 자식을 참조할 수 있는 `children`  프로퍼티도 노출시킴

```kotlin
fun main() = runBlocking {
    launch {
        delay(1000)
        println("Test1")
    }
    launch {
        delay(1000)
        println("Test1")
    }
    
    val children = coroutineContext[Job]?.children // children property
    
    val childrenNum = children?.count()
    println("Number of children: $childrenNum") // 2
    
    children?.forEach { it.join() }
    println("All tests are done")
}
```



## 잡 팩토리 함수 - Job()

* 어떤 코루틴과도 연관되지 않는 Job을 생성할 수 있다!
  * 생성된 코루틴 내 외에 다른 코루틴에서도 사용 가능
* 해당 job은 컨텍스트 또는 한 개 이상의 코루틴을 가진 부모 job으로 사용 가능
* Job()은 생성자처럼 보이는 팩토리 함수로, 가짜 생성자!
  * 실제로 반환하는 타입도 Job이 아닌 CompletableJob

```kotlin
public fun Job(parent: Job? = null): CompletableJob
```

#### 주의

* Job() 팩토리 함수를 사용해 Job을 생성하고, 다른 코루틴의 부모로 지정한 뒤에 join 호출하지 않기!
  * 이 경우 자식 코루틴이 모두 작업을 끝마쳐도 Job은 여전히 Active 상태 > 프로그램이 종료되지 않음

```kotlin
suspend fun main() = coroutineScope {
    val job = Job()
    launch(job) { // 새로운 job, 부모로부터 상속받은 job을 대체함
        delay(1000)
        println("Text1")
    }
    
    launch(job) { // 새로운 job, 부모로부터 상속받은 job을 대체함
        delay(2000)
        println("Text2")
    }
    job.join()
    println("will not be printed")
}

// (1초 후)
// Text1
// (2초 후)
// Text2
// 영원히 실행됨,,,
```

* 대신 Job의 모든 자식 코루틴에서 join을 호출하게 해야 함

```kotlin
suspend fun main() = coroutineScope {
    val job = Job()
    launch(job) { // 새로운 job, 부모로부터 상속받은 job을 대체함
        delay(1000)
        println("Text1")
    }
    
    launch(job) { // 새로운 job, 부모로부터 상속받은 job을 대체함
        delay(2000)
        println("Text2")
    }
   
   job.children.forEach { it.join() }
}

// (1초 후)
// Text1
// (2초 후)
// Text2
```



## CompletableJob

```kotlin
public interface CompletableJob: Job {
    public fun complete(): Boolean
    public fun completeExceptionally(exception: Throwable): Boolean
}
```

* complete(): Boolean
  * job을 완료하는데 사용
  * 모든 자식 코루틴은 작업이 완료될 때까지 실행된 상태를 유지하지만, complete을 호출한 Job에서 새로운 코루틴이 시작될 수는 없음
  * job이 완료되면 실행 결과 true / 그렇지 않은 경우 false (ex. 이미 job이 완료된 경우)

```kotlin
suspend fun main() = coroutineScope {
    val job = Job()
    launch(job) {
        delay(1000)
        println("Text1")
    }
    launch(job) {
        delay(2000)
        println("Text2")
    }
    job.complete() // job의 마지막 코루틴을 시작 후 자주 사용
    job.join()
    
    // complete을 명시적으로 해줬기 때문에 프로그램 영원히 실행되지 않음??
}

// (1초 후)
// Text1
// (1초 후)
// Text2
```

* completeExceptionally(exception: Throwable) : Boolean
  * 인자로 받은 예외로 job을 완료시킨다
  * 주어진 예외는 CancellationException 으로 래핑되어 즉시 취소됨

