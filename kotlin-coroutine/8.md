# 8장 잡과 자식 코루틴 기다리기

## Job 이란?

* 수명을 가지고 있고 취소 가능한 컨텍스트
* 인터페이스지만, 구체적 사용법과 상태를 가지고 있는 추상 클래스처럼 사용 가능



### job의 상태

* NEW
  * 지연 시작되는 코루틴만 New 상태에서 시작됨
  * 작업이 실행되면 Active 상태가 된다
* ACTIVE
  * 대부분의 코루틴의 시작 상태
  * job이 실행되고 코루틴은 job을 수행함 (job이 코루틴 빌더에 의해 생성됨 > 코루틴 본체 실행)
  * _isActive = true_
* COMPLETITNG
  * job 실행이 완료된 상태
  * 자식들을 기다림
  * _isActive = true_
* COMPLETED
  * 자식들도 실행이 모두 끝난 상태
  * _isCompleted = true_
* CANCELLING
  * Active 또는 Completing 상태에서 취소 or 실패한 상태
  * 연결을 끊거나, 자원을 반납하는 등 후처리 작업을 할 수 있음
  * _isCancelled = true_
* CANCELLED
  * Cancelling 에서 후처리 작업을 완료한 상태
  * _isCancelled = true_
  * _isCompleted = true_

<figure><img src="../.gitbook/assets/스크린샷 2024-05-29 오후 5.24.06.png" alt=""><figcaption><p>job lifecycle</p></figcaption></figure>





## 코루틴 빌더는 부모의 job을 기초로 자신들의 job을 생성한다

* 모든 코루틴 빌더는 자신만의 job을 생성 & 반환 > 어느 곳에서든 사용할 수 있다
* launch - 명시적 반환 타입이 Job
* async - Deferred\<T> 또한 Job 인터페이스를 구현하고 있음

```kotlin
fun main(): Unit = runBlockking {
    val job = launch {
        delay(1000)
        println("Test")
    }
}
```

```kotlin
fun main() = runBlocking {
    val deferred = async {
        delay(1000)
        "Test"
    }    
    val job = deferred
}
```

* Job은 코루틴 컨텍스트이므로 coroutineContext\[Job]을 사용해서 접근 가능

```kotlin
val CoroutineContext.job: Job
    get() = get(Job) ?: error("Current context doesn't...")
    
val main() = runBlocking {
    print(coroutineContext.job.isActive)
}
```

* **코루틴이 상속하지 않는 유일한 코루틴 컨텍스트**
* 모든 코루틴은 자신만의 Job을 생성 & 인자 또는 부모 코루틴으로부터 온 Job은 새로운 Job의 부모로 사용

```kotlin
fun main() = runBlocking {
    val name = CoroutineName("Some name")
    val job = Job()
    
    launch(name + job) {
        val childName = coroutineContext[CoroutineName]
        println(childName == name) // true
        
        val childJob = coroutineContext[Job] // child scope에서 생성한 job?
        println(childJob == job) // false 전달받은 job은 새로운 Job의 부모로 사용
        println(childJob == job.children.first()) // true
    }
}
```

* 부모 job와 자식 job 은 서로 참조 가능&#x20;

```kotlin
fun main() = runBlocking {
    val job = launch {
        delay(1000)
    }
    
    val parentJob = coroutineContext.job // coroutineContext[Job]
    println(job == parentJob) // false
    
    val parentChildren = prentJob.children
    println(parentChildren.first() == job) // true
}
```

* 새로운 Job 컨텍스트가 부모의 job을 대체하면 구조화된 동시성 작동 방식은 무효

```kotlin
fun main() = runBlocking {
    launch(Job()) { // 새로운 job이 부모로부터 상속받은 job을 대체
        delay(1000)
        println("will not be printed")
    }
}

// 프로그램 종료
// 구조화된 동시성이 제대로 작동했다면 부모 scope runBlocking이 자식인 launch 를 기다려줬을 것
// job이 대체되면서 부모-자식 관계가 성립하지 않게 됨
```



### 자식들 기다리기 - join

* join - 지정한 job이 Completed 나 Cancelled 같은 상태에 도달할 때까지 기다리는 중단함수

```kotlin
fun main() = runBlocking {
    val job1 = launch {
        delay(1000)
        println("Test1")
    }
    
    val job2 = launch {
        delay(2000)
        println("Test2")
    }
    
    job1.join()
    job2.join()
    println("All tests are done")
}

// (1초 후)
// Test1
// (2초 후)
// Test2
// All tests are done
```

* job 인터페이스는 모든 자식을 참조할 수 있는 `children`  프로퍼티도 노출시킴

```kotlin
fun main() = runBlocking {
    launch {
        delay(1000)
        println("Test1")
    }
    launch {
        delay(1000)
        println("Test1")
    }
    
    val children = coroutineContext[Job]?.children // children property
    
    val childrenNum = children?.count()
    println("Number of children: $childrenNum") // 2
    
    children?.forEach { it.join() }
    println("All tests are done")
}
```

