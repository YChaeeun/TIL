---
description: '클래스, 객체, 인터페이스'
---

# 4장

## 클래스 계층 정의

### interface 인터페이스

* 추상 메소드 뿐만 아니라 구현이 있는 메소드도 정의 가능
* 단, 아무런 상태\(필드\)도 들어갈 수 없음
* interface member 에는 final, open, abstract 사용하지 않음

  * 기본적으로 추상
  * abstract 는 붙일 필요 없음

  ```kotlin
  interface Clickable {
      fun click() // 일반 메소드
      fun showOff() = println("show!") // 디폴트 구현이 있는 메소드 default 붙일 필요 없음
  }

  /* implement */
  class Button : Clickable {
      override fun click() = println("clicked")
  }
  ```

* 콜론 : 으로 자바의 extends 와 implements 모두 처리
  * 단, 자바와 마찬가지로 클래스는 인터페이스는 원하는 만큼 구현할 수 있지만, 클래스를 오직 하나만 확장 가능
* override 변경자 필수!!

#### 동일한 메소드를 가진 다른 인터페이스가 있는 경우

* 예를 들어 위의 Clickable.showOff\(\) 와 동일한 메소드가 있는 다른 인터페이스 Focusable 이 있고, 이 둘을 구현하는 클래스가 있다면??

  * 코틀린에서는 두 메소드를 아우르는 구현을 하위 클래스에서 하도록 강제 함

  ```kotlin
  interface Focusable {
      fun showOff() = println("show focusable")
  }

  class Button : Clickable, Focusable {
      override fun click() = println("Clickable click")
      override fun showOff() {
          super<Clickable>.showOff()
          super<Focusable>.showOff()
      }
    
      // 하나만 구현해도 되는 경우에는 아래와 같이 써도 됨
      override fun showOff() = super<Clickable>.showOff() 
  }
  ```



### 기본적으로 final

* fragile base class 취약한 기반 클래스 문제 예방을 위해서 코틀린은 기본적으로 final 
  * fragile base class 취약한 기반 클래스 문제
    * 하위 클래스가 기반 클래스의 의도와 어긋나게 메소드를 오버라이드 하는 경우 등등의 문제로 하위 클래스의 동작이 예기치 않게 변경되는 문제
  * 자바에서는 기본이 public / 상속을 원하지 않는 경우에 final 로 만들어야 함
* 기본값이 final 이라서 **스마트 캐스트** 가능
  * 스마트 캐스트는 타입 검사 후 변경될 수 없는 변수에만 적용 가능하기 때문
* open 변경자

  * 클래스의 상속, 메소드, 프로퍼티의 오버라이드를 허용하고 싶은 경우에 붙임
  * override 메소드는 기본적으로 열려있음
    * 하위 클래스의 오버라이드를 원하지 않을 경우 final 추가

  ```kotlin
  open class Button : Clickable {
      fun disable()     // 상속 불가 (기본값 final)
      open fun animate() // 오버라이드 가능!
      override fun click() // 오버라이드 된 메소드는 기본적으로 open
      final override fun click2() // 하위 클래스의 오버라이드를 원하지 않을 경우 final 추가
  } 
  ```



### abstract 추상 클래스

* abstract

  * 인스턴스화 불가능
  * 하위 클래스에서 추상 멤버를 오버라이드 해서 구현해야 함
    * 추상 멤버는 항상 open
    * 추상 멤버에는 구현이 있으면 안됨

  ```kotlin
  abstract class Animate() {
      abstract fun animate() // 추상, 기본 open, 하위 클래스에서 반드시 override 해야 함
    
      fun start() { // 비추상, 기본 final
      }
      open fun stop() { // 비추상, 기본 final, 상속을 허용하려면 open 을 붙여줘야 함
      }
    
  }
  ```



### visibility modifier 가시성 변경자 : public, protected, private

* 선언에 대한 클래스의 외부 접근을 제어
* 규칙

  * 가시성이 높다 --- public &gt;&gt;  internal  &gt;&gt; protected &gt;&gt; private  -- 낮다
  * 어떤 클래스의 기반 타입 / 제네릭 클래스의 타입 파라미터에 들어있는 타입의 가시성은 클래스 자신의 가기성과 같거나 높아야 함
  * 메소드의 시그니처에 사용된 모든 타입의 가시성은 그 메소드의 가시성과 같거나 더 높아야 한다
    *  그래야 어떤 함수를 호출하거나 클래스 확장할 때 필요한 모든 타입에 접근할 수 있음
  * 클래스를 확장한 함수는 해당 클래스의 protected, private 에 접근 불가

* 자바와 다른 변경자는 어떻게 컴파일 되나?
  * private class
    * 자바에서는 클래스를 private 로 만들 수 없는데, 코틀린은 가능 \(최상위 선언 가능\)
    * 이 경우 코틀린에서는 private 클래스 를 패키지 - 전용 클래스로 컴파일
  * internal
    * 자바에는 없음 \(...\)
      * 모듈은 여러 패키지로 이뤄져 있고, 서로 다른 모듈인데 같은 패키지에 속한 경우도 있을 수 있어서 패키지-전용으로 컴파일 안됨
    * 바이트코드 상에서는 public 이 됨
  * 이런 차이 때문에 코틀린에서는 접근이 안되는데 자바에서는 되는 경우가 있음 

    * ex\) protected 를 같은 패키지에서 접근 가능 \(코틀린에서는 안되는게 맞음\)
* **public**
  * 모든 곳에서 볼 수 있음
  * 코틀린에서는 아무 변경자가 없을 경우 모두 public
    * 자바는 default
* **internal**
  * 같은 모듈 안에서만 볼 수 있음 \(자바 package-private 의 대안\)
    * 모듈
      *  한번에 한꺼번에 컴파일되는 코틀린 파일
      * ex\) 인텔리J, 이클립스, 메이븐, 그레이들 등의 프로젝트
  * 자바에서는 패키지 내부에 쉽게 외부 프로젝트가 접근할 수 있어서 모듈의 캡슐화가 쉽게 깨지는데, 코틀린에서는 internal 로 이를 방지
* **protected**
  * 해당 클래스 혹은 그 클래스를 상속받은 하위 클래스에서만 볼 수 있음
  * 최상위 선언에 적용할 수 없음
  * 자바와 달리 코틀린에서는 같은 패키지 내라고 해도 접근 불가
* **private**
  * 같은 클래스 내에서 볼 수 있음
  * 코틀린에서는 최상위 선언에 대해서도 private 를 허용
    * 최상위 선언 - ex\) 클래스, 함수, 프로퍼티
  * 시스템의 자세한 구현 사항을 외부에 감추고 싶을 때 사용

### 내부 클래스 & 중첩된 클래스

* 자바와 달리, nested class 중첩 클래스는 명시적으로 요청하지 않는 한, 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없음
* 자바의 경우 
  * 클래스 안에 정의한 클래스가 **자동으로 내부 클래스 inner class** 가 되면서 내부 클래스는 외부 클래스를 묵시적으로 참조하게 된다 --&gt; 바깥 클래스 직렬화 안됨
  * 이를 해결하려면 안에 정의한 클래스를 static 으로 선언해서 바깥쪽 클래스에 대한 묵시적 참조를 없애야 함
    * 코틀린의 경우 자바와 정 반대로 동작
* 코틀린의 경우
  * **아무런 변경자가 붙지 않은 경우, 자바 static 중첩 클래스와 동일**하게 동작 \(참조 x\)
  * 이를 내부 클래스로 변경해서 바깥쪽 클래스의 참조를 포함하고 싶다면 inner 변경자를 붙여야 함
  * inner class 에서 outer class 를 참조하고 싶은 경우
    * this@Outer 라고 표기해줘야 한다

| 클래스 A 안에 있는 클래스 B | 자바의 경 | 코틀린의 경 |
| :--- | :--- | :--- |
| 중첩 클래스 nested \(외부 클래스 참조 X\) | static class B | class B |
| 내부 클래스 inner \(외부 클래스 참조 O\) | class B | inner class B |

{% hint style="success" %}
#### 자바 직렬화 Serializable

자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 byte 형태로 변환하는 기술 \(혹은 변환된 데이터를 다시 개게로 변환하는 기술\)

JVM 메모리에 있는 객체 데이터를 바이트 형태로 변환 / 직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM 에 상주
{% endhint %}



### 봉인된 클래스 sealed class

* 클래스 계층 정의 시 계층 확장을 제한할 수 있음
* sealed Class 의 하위 클래스는 딱 이것만 있다!고 명확하게 표시 가능
* sealed 는 인터페이스에서는 붙일수가 없음
  * 그런 인터페이스를 자바에서는 구현할 수 없기 때문에,,

```kotlin
sealed class Expr {
    class Num(val value: Int) : Expr()
    class Sum(val left: Int, val right: Int) : Expr()
}

fun eval(expr: Expr) {
    when (expr) {
        is Expr.Num -> e.value
        is Expr.Sum -> eval(e.right) + eval(e.left)
        
        // 만약 Expr 이 sealed class 가 아니였다면, else 분기처리를 따로 해줬어야 함
        // 그렇게 되면, 모든 경우를 제대로 검사했는지 보장 X
        // 나중에 Expr 하위클래스가 추가되었을 경우 분기처리에서 누락할 경우 버그가 펑펑;;
    }
}
```



## 클래스 선언

### primary constructor 주 생성자 & init 초기화

* 주생성자
  * 클래스 선언 시 클래스 이름 뒤에 붙는 괄호\(\)로 둘러인 부분
  * 생성자 파라미터를 지정
  * 생성자 파라미터에 의해 초기화되는 프로퍼티 정의
    * 괄호 안 val 은 해당 파라미터에 상응하는 프로퍼티가 생성된다는 의미
    * 별도로 val name; init { name = \_name } 이런 부분 불필요
  * 디폴트 값
    * 생성자 파라미터에 대한 디폴트 값을 제공해 줄 수 있음
    * `class User (val name: String="chae")`
    * 모든 생성자 파라미터에 디폴트 값을 주게 되면, 컴파일러가 자동으로 파라미터가 없는 생성자를 만들어 주고, 디폴트 값을 사용해서 클래스를 초기화 함
      * 자바 라이브러리 중에 파라미터가 없는 생성자를 통해서 객체를 생성해야만 라이브러리 사용이 가능한 경우가 있는데, 이런 경우에 통합을 쉽게 해준다 
* constructor
  * 주 생성자나 부 생성자를 정의할 때 사용
* init
  * 초기화 블록을 시작할 때 사용
  * 필요하다면 클래스 내에서 여러 초기화 블록 사용 가능

```kotlin
// 방법 1
class User(val name: String)
        // 이때 val 은 해당 파라미터에 상응하는 프로퍼티가 생성된다는 뜻!!
    
  
// 방법 2 
class User constructor(_name: String) {

    val name: String
    
    init {    // init 초기화 블록
        name = _name  
        // _name 대신에 파라미터값을 name 으로 받고 this.name = name 해줘도 됨
    }

}

// 방법 3
class User (_name: String) {
    val name = _name
}


```

* 기반 클래스가 있는 경우, 주 생성자에서 기반 클래스의 생성자를 호출해 줘야 함

  * 기반 클래스 \(ex. User\) 뒤에 괄호 치고 생성자 인자를 넘겨주면 됨

  ```kotlin
  open class User(val name: String)
  class Student(name: String) : User(name) {}
  ```

* 별도로 생성자를 정의하지 않으면 컴파일러가 알아서 아무일도 하지 않는 인자 없는 디폴트 생성자를 만들어 준다

  * Button 의 생성자는 아무 인자도 필요가 없지만, 해당 클래스를 상속한 하위 클래스는 반드시 생성자를 호출해 줘야 함 -&gt; Button\(\)
  * 그래서 코틀린의 모든 클래스는 생성자 괄호 \(\) 를 가지고, 생성자가 없는 인터페이스는 괄호\(\) 가 없다

  ```kotlin
  open class Button // 아무런 생성자도 없는 디폴트 생성자 

  class RadioButton : Button() // Button() 생성자 필수!
  ```

* 외부에서 클래스 인스턴스화를 막고 싶다면 private constructor\(\) 를 사용하면 된다~!

  * 이때 주 생성자가 비공개이므로 외부에서 해당 클래스를 인스턴스화 할 수 없다
  * 동반 객체 companion object 안에서 유용하게 쓰인다고 함

  ```
  class Secrete private constructor() {}
  ```



### 부 생성자 secondary constructor

* 주 생성자가 없는 경우, 부 생성자가 반드시 상위 클래스를 초기화 하거나 다른 생성자에게 생성을 위임해야 함
* 자바와의 상호 운용성 때문에 필요한 경우가 많음 
  * 프레임 워크 확장을 위해서 여러 방식의 생성자를 지원해야 하는 경우
  * 파라미터 목록이 다른 생성 방법이 여러 개 존재하는 경우

```kotlin
open class View { // 주 생성자 없음
    constructor(context: Context) {
        // code ...
    }
    
    constructor(context: Context, attr: Attribute){
        // code ...
    }
     
}


class MyButton : View { // 클래스 확장 시에도 생성을 위임하는 식으로 사용 
    constructor(context: Context) : super(context)
    
    constructor(context: Context, attr: AttributeSet) : super(context, attr)
}


class MyButton : View { // super 대신 this 를 사용할 수도 있음
    constructor(context: Context) : this(context, MY_STYLE)
            // 이 경우 아래 부 생성자로 생성을 위임
    
    constructor(context: Context, attr: AttributeSet) : super(context, attr)
}
```



