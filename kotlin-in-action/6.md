---
description: 코틀린 타입 시스템
---

# 6장

## 널 가능성 nullability

* NPE \(null point exception\) 을 피할 수 있도록 돕는 코틀린 타입 시스템의 특성
* null 이 될 수 있을지 여부를 컴파일 시점에서 판단할 수 있도록 해서, 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다

### 널이 될 수 있는 타입 ?

* 타입 뒤에 ? 를 붙이는 경우에만 해당 변수가 null 이 될 수 있음을 명시적으로 표시
  * ? 가 붙지 않는 경우 null 이 될 가능성이 없다는 것을 보장할 수 있음
* 널이 되는 경우를 알 수 있으므로, 해당 경우에만 널 검사를 추가하는 등의 처리를 해줄 수 있다
* 널이 될 수 있는 타입의 변수는,,
  * 변수.메소드\(\) 처럼 직접 호출할 수 없고
  * 널이 될 수 없는 변수에 해당 변수 값을 할당할 수도 없고
  * 널이 될 수 없는 타입을 인자로 받는 함수에 널이 될 수 있는 변수를 인자로 넘길 수도 없음

### 안전한 호출 연산자 ?.

* null 검사화 메소드 호출을 한 번에 수행한다
* null 이 아닌 경우에만 메소드 호출, null 인 경우에는 무시됨
  * 안전한 호출의 결과 타입도 nullable 일 수 있음
* 연쇄적으로 안전한 호출 연산자를 사용할 수 있음

```kotlin
fun allString(s: String?) {
    val all: String? = s?.toUpperCase() // 결과값이 nullable 일 수 있음
}

fun printAddress(address : Address?) {
    val country = address?.country?.postalCode // 연쇄적으로 사용 가능
}
```

### 엘비스 연산자 \(null coalescing 연산자\) ?:

* null 대신 사용할 default 값을 정해둘 수 있음
* 좌항이 null 이 아니면 좌항 값을 결과로, null 이라면 우항 값을 결과로

```kotlin
fun allString(s: String?) {
    val all: String = s?.toUpperCase() ?: "unknown"
                // s?.toUpperCase() 가 null 이면 "unkonwn" 을 결과값으로 가짐
}
```

### 안전한 캐스트 as?

* is 타입 검사와 캐스팅을 한번에 처리
* 변환을 시도했을 때 타입이 맞지 않으면 null 을 반환한다

```kotlin
fun isPerson(o: Any?) : Boolean {
    val other = o as? Person ?: return false 
            // o 를 Person 으로 안전한 캐스트, null 인 경우 false 반환
    return true
}
```

### 널 아님 단언 !! 

* 널이 될 수 없는 타입으로 \(강제로\) 바꾼다
  * 근데 만약 해당 변수가 null 이었다면 NPE 발생
* 되도록 쓰지 말고 다른 방법을 찾아보자,,

### let 함수

* 자신의 수신객체를 인자로 전달받은 람다로 넘기는데, 안전한 호출로 넘긴 수신 객체를 널이될 수 없는 타입의 값으로 바꿔서 람다에 전달한다

```kotlin
// email 이 null 이라면 아무일도 일어나지 않는다
email?.let { e -> sendEmail(e)} 
email?.let { sendEmail(it) }  // e 생략하고 그냥 it 써도 됨
```

### 나중에 초기화 할 프로퍼티 lateinit

* 코틀린에서는 일반적으로 생성자에서 모든 프로퍼티를 초기화해야 한
  * 특히 널이 될 수 없는 타입의 변수를 생성자 안에서 초기화 하지 않고, 나중에 특별한 메소드에서 초기화 할 수 없다
  * 그래서 초기화 값을 바로 제공하지 못한다면 nullable 타입을 사용하거나 !! 를 사용할 수 밖에 없다
  * 이러는 경우 계속 코드 내에서 ?. 나 !! 를 써야 해서 넘 지저분,,
    * 이걸 해결하기 위해서 lateinit 을 사용하면 된다
* lateinit 변경자를 붙이면, 프로퍼티를 나중에 초기화 할 수 있다
  * 단, 생성자 내에서 반드시 초기화 되어야 한다
  * 항상 var 이어야 함

```kotlin
class Test {
    private var myService : MyService? = null // 널이 될 수 있는 타입으로 초기화
    
    @Before fun setUp() {
        myService = MyService()
    }
    
    fun sample() {
        myService?.doAction()    // 지저
        myService!!.doAction2()  // 지저분
    }
}

/* ------------------------------------ */
// 대신 lateinit 을 사용하자
class Test {
    private lateinit var myService: MyService // 널이 될 수 없는 타입 & 초기화 나중에
    
    @Before fun setUp() { 
        myService = MyService() // 초기화 해줌! 
    } 
    
    fun sample() {
        myService.doAction()    // 널이 될 수 없는 타입이므로 ?, !! 안써도 됨
        myService.doAction2()  
    }
}
```

### 널이 될 수 있는 타입 확장

* 널이 될 수 있는 타입의 확장함수를 정의하면, 안전한 호출을 하지 않고도 null 을 알아서 처리해줄 수 있다
  * 단 수신 객체 this 가 널이 아니라는 뜻은 아니어서 명시적으로 null 검사는 해줘야 함 `this == null`

```kotlin
fun String?.isNullOrBlank() = this == null || this.isBlank()
                                // 이때 두 번째 this 는 스마트 캐스트
                                // 왜냐면 this == null 앞에서 false니까 뒤로 넘어온거라서                       
                                // this 는 null 이 될 수 없음
                                
fun verify(input : String?) {
    if (input.isNullOrBlank) {  // ?. 해줄 필요 없음
    }
}         
```

### 타입 파라미터의 널 가능성

* 모든 타입 파라미터는 기본적으로 null 이 될 수 있고, 널이 될 수 있는 타입을 포함하는 어떤 타입이라도 타입 파라미터를 대신 할 수 있다
* 타입 파라미터가 널이 될 수 없음을 확실히 하려면 널이 될 수 없는 타입 상한upper bound 를 지정해야 한다

```kotlin
fun <T> printHash(t: T) { // 이때 t 는 널이 될 수도 있다
    t?.hashCode()
}

printHash(null) // 가능

/* ---------------------------- */

fun <T: Any> printHash(t: T) { // 널이 될 수 없게 하려면 <T: Any> 로 명시해줘야 함
    t.hashCode()
}

printHash(null) // 불가능!!
```



## 코틀린의 원시 타입

