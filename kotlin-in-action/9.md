---
description: 제네릭스
---

# 9장

## 제네릭 타입 파라미터

* 제네릭스를 사용하면 **타입 파라미터type parameter**를 받는 타입을 정의할 수 있음
* 제네릭 타입의 인스턴스를 만드려면, 타입 파라미터를 구체적인 **타입 인자 type argument**로 치환해야 한다
  * **Map&lt;K,V&gt;** 타입 파라미터는 **Map&lt;String, Int&gt;** 처럼 구체적인 타입 인자를 가질 수 있다

### 제네릭 함수와 프로퍼티

* 제네릭 함수를 호출할 때는 반드시 구체적 타입으로 타입 인자를 넘겨야 함

  * 단, 코틀린에서는 타입을 추론할 수 있으므로 대부분 명시적으로 안적어줘도 됨

  ```kotlin
  fun <T> List<T>.slice(indices: IntRange) : List<T>
  // 타입 파라미터 T

  val letters = ('a'..'z').toList()
  >> letters.slice<Char>(0..2)  //타입 명시적으로
  >> letters.slice(0..2)        //컴파일러는 여기서 T 가 Char 임을 추론할 수 있음
  ```

* 제네릭 확장 프로퍼티

  * 일반 프로퍼티는 타입 파라미터를 가질 수 없다 \(오직 확장 프로퍼티만 가능!\)
    * 왜냐면 클래스 프로퍼티에 여러 타입의 값을 저장할 수 없기 때문에,,

  ```kotlin
  val <T> List<T>.penultimate: T
      get() = this[size-2]
    
  >> listOf(1,2,3,4).penultimate // 3

  // 요건 안돼
  val <T> v: T = ToDo() // 일반 프로퍼티는 제네릭할 수 없음
  ```

### 제네릭 클래스 선언

* 타입 파라미터를 넣은 &lt;&gt; 기호를 클래스\(혹은 인터페이스\) 이름 뒤에 붙이면 클래스\(혹은 인터페이스\)를 제네릭하게 만들 수 있다

  ```kotlin
  interface List<T> {
      operator fun get(index: Int) : T
      ....
  }
  ```

* 제네릭 클래스를 확장하는 클래스를 정의하려면, 기반 타입의 제네릭 파라미터에 대해 타입 인자를 지정해야 한다

  * 구체적인 타입을 넘길 수도 있고,
  * 하위 클래스도 제네릭 클래스라면, 타입 파라미터로 받은 타입을 넘겨도 됨

  ```kotlin
  class StringList: List<String> {    // 구체적인 타입 String 을 넘김
      override fun get(index: Int) : String
  }

  class ArrayList<K> : List<K> {    // 상위 클래스의 타입 파라미터로 받은 타입을 넘김
      overide fun get(index: Int) : K    // 이때 K 는 그냥 이름,, 암거나 상관 X
  }
  ```

* 자기자신을 타입 인자로 참조할 수도 있음

  ```kotlin
  interface Cmparable<T> {
      fun compareTo(other: T) : Int
  }

  class String: Comparable<String> {    // String 자기자신을 타입 파라미터 T 로 지정
      override fn compareTo(other: String) : Int
  }
  ```

### 타입 파라미터 제약 type parameter constraint

* 어떤 타입을 제네릭 타입의 타입 파라미터에 대한 상한upper bound 으로 지정하면, 그 제네릭 타입을 인스턴스화 할 때 사용하는 타입 인자는 반드시 그 상한 타입이거나, 그 상한 타입의 하위 타입이어야 함
  * 상한 타입을 Number로 지정하면, 인스턴스화할 때 타입 인자는 Int, Double 등 Number 의 하위 타입이어야 한다
  * `fun <T: Number> List<T>.sum() : T`



